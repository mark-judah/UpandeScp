[
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Bed And Zone Automation",
  "enabled": 1,
  "modified": "2025-10-11 18:12:49.127994",
  "module": "Upande Scp",
  "name": "Bed And Zone Automation Tool",
  "script": "frappe.ui.form.on('Bed And Zone Automation', {\n    refresh: function(frm) {\n        if (frm.doc.docstatus === 0 && !frm.is_new()) {\n            frm.add_custom_button(__('Run Automation'), function() {\n                frappe.confirm(\n                    __('This will create new Bed and Zone documents. Do you want to continue?'),\n                    () => {\n                        frappe.call({\n                            method: \"createBedsAndZones\",\n                            args: {\n                                doc_name: frm.doc.name\n                            },\n                            freeze: true,\n                            freeze_message: \"Automating zone and bed creation...\",\n                            callback: function(r) {\n                                if (r.message) {\n                                    frappe.msgprint(r.message);\n                                }\n                                frm.reload_doc();\n                            },\n                            error: function(r) {\n                                if (r.message) {\n                                    frappe.msgprint(r.message);\n                                }\n                            }\n                        });\n                    }\n                );\n            });\n        }\n    }\n});\n",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Warehouse",
  "enabled": 1,
  "modified": "2025-10-11 18:12:49.445857",
  "module": "Upande Scp",
  "name": "Greenhouse Map",
  "script": "frappe.ui.form.on('Warehouse', {\n    refresh(frm) {\n        console.debug('[Warehouse Script] Starting refresh function at', new Date().toISOString());\n        // Use a slight delay to ensure the map is fully loaded\n        setTimeout(() => {\n            console.debug('[Warehouse Script] Inside setTimeout');\n            const mapControl = frm.fields_dict['custom_location'];\n            if (!mapControl || !mapControl.map) {\n                console.warn('[Warehouse Script] Map control or map instance not found');\n                return;\n            }\n            const map = mapControl.map;\n            console.debug('[Warehouse Script] Map instance retrieved:', map);\n\n            // Clear existing layers from the map to avoid duplicates\n            console.debug('[Warehouse Script] Clearing existing layers');\n            map.eachLayer(layer => {\n                if (!layer._url) { // Keep base layers, remove other layers\n                    map.removeLayer(layer);\n                }\n            });\n            console.debug('[Warehouse Script] Layers cleared');\n\n            // Define base layers\n            console.debug('[Warehouse Script] Setting up base layers');\n            const satellite = L.tileLayer(\n                'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {\n                    attribution: '© Esri',\n                    maxZoom: 19\n                }\n            );\n\n            const osm = L.tileLayer(\n                'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: '© OpenStreetMap contributors',\n                    maxZoom: 19\n                }\n            );\n\n            // Add base layers and a control to switch between them\n            console.debug('[Warehouse Script] Adding base layers to map');\n            satellite.addTo(map);\n            const baseLayers = { \"Satellite View\": satellite, \"Street Map\": osm };\n            L.control.layers(baseLayers, null, { position: 'topright' }).addTo(map);\n            console.debug('[Warehouse Script] Base layers and control added');\n\n            // --- Custom GeoJSON Logic ---\n            const rawGeoJSON = frm.doc.custom_raw_geojson;\n            console.debug('[Warehouse Script] Raw custom_raw_geojson:', rawGeoJSON);\n            if (rawGeoJSON) {\n                try {\n                    // Sanitize and parse the GeoJSON string\n                    console.debug('[Warehouse Script] Sanitizing GeoJSON');\n                    let cleanedGeoJSON = rawGeoJSON.trim();\n                    if (cleanedGeoJSON.startsWith('\"') && cleanedGeoJSON.endsWith('\"')) {\n                        cleanedGeoJSON = cleanedGeoJSON.slice(1, -1).replace(/\\\\\"/g, '\"');\n                    }\n                    console.debug('[Warehouse Script] Cleaned GeoJSON:', cleanedGeoJSON);\n\n                    console.debug('[Warehouse Script] Parsing GeoJSON');\n                    const geojson = JSON.parse(cleanedGeoJSON);\n                    console.debug('[Warehouse Script] Parsed GeoJSON:', geojson);\n\n                    if (geojson.type === 'FeatureCollection' && geojson.features && geojson.features.length > 0) {\n                        console.debug('[Warehouse Script] Valid FeatureCollection detected, features:', geojson.features.length);\n                        // Create a feature group to hold all polygons\n                        const featureGroup = L.featureGroup();\n                        console.debug('[Warehouse Script] Feature group created');\n\n                        // Process each feature in the FeatureCollection\n                        geojson.features.forEach((feature, index) => {\n                            console.debug(`[Warehouse Script] Processing feature ${index}:`, feature);\n                            if (feature.geometry && feature.geometry.type === 'Polygon') {\n                                // Draw the polygon on the map\n                                console.debug(`[Warehouse Script] Adding polygon for feature ${index}`);\n                                const geoJsonLayer = L.geoJSON(feature, {\n                                    style: {\n                                        color: \"#2b7fd4\",\n                                        weight: 3,\n                                        opacity: 0.8,\n                                        fillOpacity: 0.2\n                                    },\n                                    onEachFeature: (feature, layer) => {\n                                        if (feature.properties && feature.properties.id) {\n                                            console.debug(`[Warehouse Script] Binding popup for feature ${index}:`, feature.properties.id);\n                                            layer.bindPopup(feature.properties.id);\n                                        }\n                                    }\n                                }).addTo(map);\n                                console.debug(`[Warehouse Script] Polygon added for feature ${index}`);\n\n                                // Add the layer to the feature group\n                                featureGroup.addLayer(geoJsonLayer);\n                                console.debug(`[Warehouse Script] Feature ${index} added to feature group`);\n                            } else {\n                                console.warn(`[Warehouse Script] Feature ${index} is not a Polygon:`, feature);\n                                frappe.msgprint(__('Invalid GeoJSON: One or more features are not Polygons.'));\n                            }\n                        });\n\n                        // Fit the map view to the bounds of all polygons\n                        console.debug('[Warehouse Script] Checking feature group bounds');\n                        if (featureGroup.getBounds().isValid()) {\n                            map.fitBounds(featureGroup.getBounds(), { padding: [50, 50] });\n                            console.debug('[Warehouse Script] Map view set to bounds');\n                        } else {\n                            console.warn('[Warehouse Script] Invalid bounds for feature group');\n                        }\n\n                        // Calculate the centroid of all polygons\n                        console.debug('[Warehouse Script] Calculating centroid');\n                        let allCoordinates = [];\n                        geojson.features.forEach(feature => {\n                            if (feature.geometry && feature.geometry.type === 'Polygon') {\n                                console.debug('[Warehouse Script] Collecting coordinates from feature:', feature.geometry.coordinates[0]);\n                                allCoordinates.push(...feature.geometry.coordinates[0]);\n                            }\n                        });\n                        console.debug('[Warehouse Script] All coordinates:', allCoordinates);\n\n                        if (allCoordinates.length > 0) {\n                            let sumLat = 0;\n                            let sumLon = 0;\n                            allCoordinates.forEach((coord, idx) => {\n                                console.debug(`[Warehouse Script] Processing coordinate ${idx}:`, coord);\n                                sumLon += coord[0];\n                                sumLat += coord[1];\n                            });\n\n                            const avgLon = sumLon / allCoordinates.length;\n                            const avgLat = sumLat / allCoordinates.length;\n                            console.debug('[Warehouse Script] Calculated centroid:', { avgLat, avgLon });\n\n                            // Set custom_location to GeoJSON Feature with point_type\n                            const locationGeoJSON = {\n                                type: \"Feature\",\n                                geometry: {\n                                    type: \"Point\",\n                                    coordinates: [avgLon, avgLat]\n                                },\n                                properties: {\n                                    point_type: \"point\"\n                                }\n                            };\n                            let locationString = JSON.stringify(locationGeoJSON);\n                            console.debug('[Warehouse Script] Setting custom_location to GeoJSON Feature:', locationString);\n\n                            // Sanitize to prevent double-stringification\n                            if (locationString.startsWith('\"') && locationString.endsWith('\"')) {\n                                locationString = locationString.slice(1, -1);\n                            }\n                            console.debug('[Warehouse Script] Final custom_location value:', locationString);\n\n                            // Set the value of the Geolocation field\n                            frm.set_value('custom_location', locationString);\n                            console.debug('[Warehouse Script] custom_location set');\n\n                            // Log plain string format for reference\n                            console.debug('[Warehouse Script] Plain string format (for reference):', `${avgLat},${avgLon}`);\n\n                        } else {\n                            console.warn('[Warehouse Script] No valid coordinates found for centroid');\n                            frappe.msgprint(__('No valid coordinates found to calculate centroid.'));\n                        }\n\n                    } else {\n                        console.warn('[Warehouse Script] Invalid GeoJSON structure:', geojson);\n                        frappe.msgprint(__('Invalid GeoJSON: Must be a FeatureCollection with Polygon features.'));\n                    }\n\n                } catch (e) {\n                    console.error('[Warehouse Script] Error processing GeoJSON:', e, 'Raw input:', rawGeoJSON);\n                    frappe.msgprint(__('Invalid JSON format in `custom_raw_geojson`. Check the console for details.'));\n                }\n            } else {\n                console.warn('[Warehouse Script] No GeoJSON data found in custom_raw_geojson');\n            }\n            console.debug('[Warehouse Script] Refresh function completed');\n        }, 300);\n    },\n\n    // Trigger the refresh logic when the field's value changes\n    custom_raw_geojson: function(frm) {\n        console.debug('[Warehouse Script] custom_raw_geojson changed, triggering refresh');\n        frm.refresh();\n    }\n});",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Pest",
  "enabled": 1,
  "modified": "2025-10-11 18:12:49.386790",
  "module": "Upande Scp",
  "name": "Pests Legend Color Toggle",
  "script": "frappe.ui.form.on('Pest', {\n    refresh: function(frm) {\n        // Set the initial value of pests_legend_color if the form is new\n        if (frm.is_new()) {\n            frm.set_value('pests_legend_color', '');\n        }\n    },\n    severity: function(frm) {\n        // Find the 'Moderate' severity row\n        const moderateRow = frm.doc.severity.find(row => row.severity === 'Moderate');\n        \n        // If a moderate row exists, update the pests_legend_color\n        if (moderateRow) {\n            frm.set_value('pests_legend_color', moderateRow.color);\n        }\n    }\n});\n\nfrappe.ui.form.on('Scouting Severity Scale', {\n    color: function(frm, cdt, cdn) {\n        const row = locals[cdt][cdn];\n        if (row.severity === 'Moderate') {\n            frm.set_value('pests_legend_color', row.color);\n        }\n    }\n});",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "BOM",
  "enabled": 1,
  "modified": "2025-10-11 18:12:48.785278",
  "module": "Upande Scp",
  "name": "BOM Toggle Fields",
  "script": "frappe.ui.form.on('BOM', {\n    after_load: function (frm) {\n        if (frm.doc.custom_item_group && frm.doc.custom_item_group.toLowerCase() === 'chemical mix') {\n            frm.clear_table('items');\n            frm.set_df_property('custom_farm', 'reqd', 0);\n            toggle_fields_visibility(frm);\n        } else {\n            reset_bom_fields(frm);\n        }\n    },\n\n    // Event triggered when the main 'item' field is changed.\n    item: function (frm) {\n        if (frm.doc.item) {\n            frappe.db.get_value('Item', frm.doc.item, 'item_group', (r) => {\n                if (r.item_group) {\n                    frm.set_value('custom_item_group', r.item_group);\n\n                    if (frm.doc.custom_item_group && frm.doc.custom_item_group.toLowerCase() === 'chemical mix') {\n                        frm.clear_table('items');\n                        frm.set_df_property('custom_farm', 'reqd', 0);\n                        toggle_fields_visibility(frm);\n                        frm.doc.items.forEach(row => {\n                            calculate_qty(frm, row.doctype, row.name);\n                        });\n                    } else {\n                        reset_bom_fields(frm);\n                    }\n                }\n            });\n        }\n    },\n\n    refresh: function (frm) {\n        if (frm.doc.custom_item_group && frm.doc.custom_item_group.toLowerCase() === 'chemical mix') {\n            frm.set_df_property('custom_farm', 'reqd', 0);\n            toggle_fields_visibility(frm);\n            frm.doc.items.forEach(row => {\n                calculate_qty(frm, row.doctype, row.name);\n            });\n        } else {\n            reset_bom_fields(frm);\n        }\n    }\n});\nfrappe.ui.form.on('BOM Item', {\n    custom_application_rateper_ha_: function(frm, cdt, cdn) {\n        if (frm.doc.custom_item_group && frm.doc.custom_item_group.toLowerCase() === 'chemical mix') {\n            calculate_qty(frm, cdt, cdn);\n        }\n    }\n});\n\nfunction calculate_qty(frm, cdt, cdn) {\n    const row = frappe.get_doc(cdt, cdn);\n    const rate = row.custom_application_rateper_ha_ || 0;\n    frappe.model.set_value(cdt, cdn, 'qty', 1 * rate);\n}\n\nfunction toggle_fields_visibility(frm) {\n    const child_table_name = 'items';\n    const all_managed_fields = [\n        'is_stock_item',\n        'allow_alternative_item',\n        'source_warehouse',\n        'custom_application_rateper_ha_'\n    ];\n    const child_grid = frm.fields_dict[child_table_name]?.grid;\n\n    if (child_grid) {\n        all_managed_fields.forEach(field => {\n            child_grid.set_column_disp(field, false);\n        });\n\n        const fields_to_show_for_chemical_mix = [\n            'custom_application_rateper_ha_'\n        ];\n        fields_to_show_for_chemical_mix.forEach(field => {\n            child_grid.set_column_disp(field, true);\n        });\n    }\n\n    const parent_fields_to_show = [\n        'custom_water_ph',\n        'custom_water_hardness',\n    ];\n\n    parent_fields_to_show.forEach(field => frm.toggle_display(field, true));\n}\n\nfunction reset_bom_fields(frm) {\n    const child_table_name = 'items';\n    const child_grid = frm.fields_dict[child_table_name]?.grid;\n\n    const standard_fields = [\n        'is_stock_item',\n        'allow_alternative_item',\n        'source_warehouse'\n    ];\n\n    const custom_fields = [\n        'custom_application_rateper_ha_'\n    ];\n\n    const parent_fields_to_show = [\n        'custom_mixing_instructions',\n        'custom_target_pests'\n    ];\n\n    parent_fields_to_show.forEach(field => frm.toggle_display(field, false));\n\n    if (child_grid) {\n        standard_fields.forEach(field => {\n            child_grid.set_column_disp(field, true);\n        });\n        custom_fields.forEach(field => {\n            child_grid.set_column_disp(field, false);\n        });\n    }\n\n    frm.set_value('allow_alternative_item', 0);\n}",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Item",
  "enabled": 1,
  "modified": "2025-10-11 18:12:49.270350",
  "module": "Upande Scp",
  "name": "Items Toggle Fields",
  "script": "frappe.ui.form.on('Item', {\n    refresh(frm) {\n        toggle_custom_fields(frm);\n        toggle_type_fields(frm, false);\n    },\n    item_group(frm) {\n        toggle_custom_fields(frm, false); // true means clear old values\n    },\n    custom_type(frm) {\n        toggle_type_fields(frm, false); // clear old values\n    },\n    custom_irac(frm) {\n        fetch_irac_moa(frm);\n    },\n    custom_frac(frm) {\n        fetch_frac_moa(frm);\n    },\n    custom_ghs(frm) {\n        fetch_ghs_description(frm);\n    }\n});\n\nfunction toggle_custom_fields(frm, clear_values = false) {\n    let group_field_map = {\n        \"Spray Roses\": [\"custom_chemical_intervention_threshhold\"],\n        \"Standard Roses\": [\"custom_chemical_intervention_threshhold\"],\n        \"Summer Flowers\": [\"custom_chemical_intervention_threshhold\"],\n        \"CHEMICALS\": [\n            \"custom_type\",\n            \"custom_ghs\",\n            \"custom_ghs_description\",\n            \"custom_toxicity\",\n            \"custom_irac\",\n            \"custom_irac_moa\",\n            \"custom_frac\",\n            \"custom_frac_moa\",\n            \"custom_reentry_interval_hrs\",\n            \"custom_active_ingredients\",\n            \"custom_targets\"\n        ],\n        \"AVOCADO CHEMICALS\": [\n            \"custom_type\",\n            \"custom_ghs\",\n            \"custom_ghs_description\",\n            \"custom_toxicity\",\n            \"custom_irac\",\n            \"custom_irac_moa\",\n            \"custom_frac\",\n            \"custom_frac_moa\",\n            \"custom_reentry_interval_hrs\",\n            \"custom_active_ingredients\",\n            \"custom_targets\"\n        ],\n    };\n\n    // Flatten all possible fields\n    let all_fields = Object.values(group_field_map).flat();\n\n    // If item_group not selected, hide and optionally clear all fields\n    if (!frm.doc.item_group) {\n        all_fields.forEach(field => {\n            frm.set_df_property(field, \"hidden\", 1);\n            if (clear_values) frm.set_value(field, null);\n        });\n        return;\n    }\n\n    // Determine which fields should be shown\n    let fields_to_show = group_field_map[frm.doc.item_group] || [];\n\n    // Hide (and optionally clear) irrelevant fields\n    all_fields.forEach(field => {\n        if (!fields_to_show.includes(field)) {\n            frm.set_df_property(field, \"hidden\", 1);\n            if (clear_values) frm.set_value(field, null);\n        }\n    });\n\n    // Show relevant fields\n    fields_to_show.forEach(field => {\n        frm.set_df_property(field, \"hidden\", 0);\n    });\n}\n\nfunction toggle_type_fields(frm, clear_values = false) {\n    let type_field_map = {\n        \"Insecticide\": [\n            \"custom_irac\",\n            \"custom_irac_moa\",\n            \"custom_reentry_interval_hrs\",\n            \"custom_active_ingredients\",\n            \"custom_targets\"\n        ],\n        \"Fungicide\": [\n            \"custom_frac\",\n            \"custom_frac_moa\",\n            \"custom_reentry_interval_hrs\",\n            \"custom_active_ingredients\",\n            \"custom_targets\"\n        ],\n        \"Adjuvant\": [],\n        \"pH Buffer\": [],\n    };\n\n    const grid = frm.fields_dict[\"custom_targets\"].grid;\n    const type = frm.doc.custom_type;\n\n    grid.toggle_display(\"disease\", type === \"Fungicide\");\n    grid.toggle_display(\"pest\", type === \"Insecticide\");\n\n    grid.refresh();\n\n    let all_type_fields = Object.values(type_field_map).flat();\n    if (!frm.doc.custom_type) {\n        all_type_fields.forEach(field => {\n            frm.set_df_property(field, \"hidden\", 1);\n            if (clear_values) frm.set_value(field, null);\n        });\n        return;\n    }\n\n    let fields_to_show = type_field_map[frm.doc.custom_type] || [];\n\n    all_type_fields.forEach(field => {\n        if (!fields_to_show.includes(field)) {\n            frm.set_df_property(field, \"hidden\", 1);\n            if (clear_values) frm.set_value(field, null);\n        }\n    });\n\n    fields_to_show.forEach(field => {\n        frm.set_df_property(field, \"hidden\", 0);\n    });\n}\n\nfunction fetch_irac_moa(frm) {\n    if (!frm.doc.custom_irac || frm.doc.custom_irac.length === 0) {\n        frm.set_value(\"custom_irac_moa\", null);\n        return;\n    }\n\n    // Collect all IRAC codes from the child table\n    let irac_codes = frm.doc.custom_irac.map(row => row.code).filter(x => x);\n\n    if (irac_codes.length === 0) {\n        frm.set_value(\"custom_irac_moa\", null);\n        return;\n    }\n\n    frappe.call({\n        method: \"frappe.client.get_list\",\n        args: {\n            doctype: \"IRAC Code\",\n            filters: { name: [\"in\", irac_codes] },\n            fields: [\"primary_site_of_action\"]\n        },\n        callback: function (r) {\n            if (r.message) {\n                let moa_list = r.message.map(d => d.primary_site_of_action);\n                frm.set_value(\"custom_irac_moa\", moa_list.join(\", \"));\n            }\n        }\n    });\n}\n\nfunction fetch_frac_moa(frm) {\n    if (!frm.doc.custom_frac || frm.doc.custom_frac.length === 0) {\n        frm.set_value(\"custom_frac_moa\", null);\n        return;\n    }\n\n    // Collect all IRAC codes from the child table\n    let frac_codes = frm.doc.custom_frac.map(row => row.code).filter(x => x);\n\n    if (frac_codes.length === 0) {\n        frm.set_value(\"custom_frac_moa\", null);\n        return;\n    }\n\n    frappe.call({\n        method: \"frappe.client.get_list\",\n        args: {\n            doctype: \"FRAC Code\",\n            filters: { name: [\"in\", frac_codes] },\n            fields: [\"mode_of_action\"]\n        },\n        callback: function (r) {\n            if (r.message) {\n                let moa_list = r.message.map(d => d.mode_of_action);\n                frm.set_value(\"custom_frac_moa\", moa_list.join(\", \"));\n            }\n        }\n    });\n}\n\nfunction fetch_ghs_description(frm) {\n    if (!frm.doc.custom_ghs || frm.doc.custom_ghs.length === 0) {\n        frm.set_value(\"custom_ghs_description\", null);\n        return;\n    }\n\n    // Collect all IRAC codes from the child table\n    let custom_ghs = frm.doc.custom_ghs.map(row => row.code).filter(x => x);\n\n    if (custom_ghs.length === 0) {\n        frm.set_value(\"custom_ghs_description\", null);\n        return;\n    }\n\n    frappe.call({\n        method: \"frappe.client.get_list\",\n        args: {\n            doctype: \"GHS Code\",\n            filters: { name: [\"in\", custom_ghs] },\n            fields: [\"description\"]\n        },\n        callback: function (r) {\n            if (r.message) {\n                let moa_list = r.message.map(d => d.description);\n                frm.set_value(\"custom_ghs_description\", moa_list.join(\", \"));\n            }\n        }\n    });\n}",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Work Order",
  "enabled": 1,
  "modified": "2025-10-11 18:12:49.000886",
  "module": "Upande Scp",
  "name": "Work Order Toggle Fields",
  "script": "frappe.ui.form.on('Work Order', {\n    after_load: function (frm) {\n        if (frm.doc.custom_type && frm.doc.custom_type.toLowerCase() === 'application floor plan') {\n            toggle_fields_visibility(frm);\n        } else {\n            reset_bom_fields(frm);\n        }\n    },\n\n    refresh: function (frm) {\n        if (frm.doc.custom_type && frm.doc.custom_type.toLowerCase() === 'application floor plan') {\n            toggle_fields_visibility(frm);\n        } else {\n            reset_bom_fields(frm);\n        }\n    }\n});\n\nfunction toggle_fields_visibility(frm) {\n    const parent_fields_to_show = [\n        'custom_validation_status',\n        'custom_greenhouse',\n        'custom_scope',\n        'custom_scope_details', \n        'custom_area',\n        'custom_water_volume',\n        'custom_water_ph',\n        'custom_water_hardness',\n        'custom_variety',\n        'custom_spray_type',\n        'custom_kit',\n        'custom_targets',\n        'custom_reentry_period_hrs',\n        'custom_scheduled_application_time',\n        'custom_reentry_time',\n        'custom_spray_team'\n    ];\n\n    parent_fields_to_show.forEach(field => frm.toggle_display(field, true));\n}\n\nfunction reset_bom_fields(frm) {\n    const parent_fields_to_show = [\n        'custom_validation_status',\n        'custom_greenhouse',\n        'custom_scope',\n        'custom_scope_details', \n        'custom_area',\n        'custom_water_volume',\n        'custom_water_ph',\n        'custom_water_hardness',\n        'custom_variety',\n        'custom_spray_type',\n        'custom_kit',\n        'custom_targets',\n        'custom_reentry_period_hrs',\n        'custom_scheduled_application_time',\n        'custom_reentry_time',\n        'custom_spray_team'\n    ];\n    parent_fields_to_show.forEach(field => frm.toggle_display(field, false));\n}",
  "view": "Form"
 },
 {
  "docstatus": 0,
  "doctype": "Client Script",
  "dt": "Work Order",
  "enabled": 1,
  "modified": "2025-10-11 18:12:49.329478",
  "module": "Upande Scp",
  "name": "Refresh Greenhouse Rentry Time",
  "script": "frappe.ui.form.on('Work Order', {\n    refresh: function(frm) {\n        if (frm.doc.custom_type !== 'Application Floor Plan') {\n            return;\n        }\n        setTimeout(function() {\n            calculate_reentry_period(frm);\n        }, 100);\n    },\n    onload: function(frm) {\n        if (frm.doc.custom_type !== 'Application Floor Plan') {\n            return;\n        }\n        calculate_reentry_period(frm);\n    },\n    after_load: function(frm) {\n        if (frm.doc.custom_type !== 'Application Floor Plan') {\n            return;\n        }\n        calculate_reentry_period(frm);\n    },\n    custom_scheduled_application_time: function(frm) {\n        if (frm.doc.custom_type !== 'Application Floor Plan') {\n            return;\n        }\n        calculate_reentry_time(frm);\n    },\n    custom_reentry_period_hrs: function(frm) {\n        if (frm.doc.custom_type !== 'Application Floor Plan') {\n            return;\n        }\n        calculate_reentry_time(frm);\n    }\n});\n\nfrappe.ui.form.on('Work Order Item', {\n    required_items_add: function(frm, cdt, cdn) {\n        if (frm.doc.custom_type !== 'Application Floor Plan') {\n            return;\n        }\n        calculate_reentry_period(frm);\n    },\n    required_items_remove: function(frm, cdt, cdn) {\n        if (frm.doc.custom_type !== 'Application Floor Plan') {\n            return;\n        }\n        calculate_reentry_period(frm);\n    },\n    item_code: function(frm, cdt, cdn) {\n        if (frm.doc.custom_type !== 'Application Floor Plan') {\n            return;\n        }\n        calculate_reentry_period(frm);\n    }\n});\n\nfunction calculate_reentry_time(frm) {\n    let scheduled_time = frm.doc.custom_scheduled_application_time;\n    let reentry_hours = frm.doc.custom_reentry_period_hrs || 0;\n\n    if (!scheduled_time) {\n        frm.set_value('custom_reentry_time', null);\n        return;\n    }\n\n    reentry_hours = parseFloat(reentry_hours);\n\n    if (isNaN(reentry_hours) || reentry_hours < 0) {\n        frappe.msgprint({\n            title: __('Error'),\n            indicator: 'red',\n            message: __('Invalid reentry period. Please check the items and try again.')\n        });\n        frm.set_value('custom_reentry_time', null);\n        return;\n    }\n\n    try {\n        let scheduled_date = new Date(scheduled_time);\n\n        if (isNaN(scheduled_date.getTime())) {\n            throw new Error('Invalid scheduled application time format');\n        }\n\n        let current_utc_hours = scheduled_date.getUTCHours();\n        scheduled_date.setUTCHours(current_utc_hours + reentry_hours);\n        \n        if (isNaN(scheduled_date.getTime())) {\n            throw new Error('Invalid reentry time calculation result');\n        }\n\n        // Manual formatting to YYYY-MM-DD HH:MM:SS\n        let YYYY = scheduled_date.getFullYear();\n        let MM = String(scheduled_date.getMonth() + 1).padStart(2, '0');\n        let DD = String(scheduled_date.getDate()).padStart(2, '0');\n        let HH = String(scheduled_date.getHours()).padStart(2, '0');\n        let mm = String(scheduled_date.getMinutes()).padStart(2, '0');\n        let SS = String(scheduled_date.getSeconds()).padStart(2, '0');\n\n        let reentry_time = `${YYYY}-${MM}-${DD} ${HH}:${mm}:${SS}`;\n\n        frm.set_value('custom_reentry_time', reentry_time);\n\n    } catch (error) {\n        frappe.msgprint({\n            title: __('Calculation Error'),\n            indicator: 'red',\n            message: __('Failed to calculate reentry time: {0}', [error.message])\n        });\n        frm.set_value('custom_reentry_time', null);\n    }\n}\n\nfunction calculate_reentry_period(frm) {\n    if (!frm.doc.required_items || frm.doc.required_items.length === 0) {\n        frm.set_value('custom_reentry_period_hrs', 0);\n        return;\n    }\n\n    let item_codes = [];\n    frm.doc.required_items.forEach(function(item) {\n        if (item.item_code) {\n            item_codes.push(item.item_code);\n        }\n    });\n\n    if (item_codes.length === 0) {\n        frm.set_value('custom_reentry_period_hrs', 0);\n        return;\n    }\n\n    frappe.call({\n        method: 'frappe.client.get_list',\n        args: {\n            doctype: 'Item',\n            filters: {\n                'name': ['in', item_codes]\n            },\n            fields: ['name', 'custom_reentry_interval_hrs']\n        },\n        callback: function(r) {\n            if (r.message) {\n                let max_reentry = 0;\n                r.message.forEach(function(item) {\n                    let reentry_hrs = item.custom_reentry_interval_hrs || 0;\n                    reentry_hrs = parseFloat(reentry_hrs);\n                    if (reentry_hrs > max_reentry) {\n                        max_reentry = reentry_hrs;\n                    }\n                });\n                frm.set_value('custom_reentry_period_hrs', max_reentry);\n            }\n        }\n    });\n}",
  "view": "Form"
 }
]