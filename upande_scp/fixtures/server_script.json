[
 {
  "allow_guest": 0,
  "api_method": "getPestsData",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.705718",
  "module": "Upande Scp",
  "name": "Get Pests Data",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "try:\n    pests = frappe.get_all(\n        \"Pest\",\n        fields=[\"name\", \"common_name\"]\n    )\n    pest_data = []\n    for pest in pests:\n        stages = frappe.get_all(\n            \"Pests Stages\",\n            filters={\"parent\": pest.name},\n            fields=[\"stage\", \"image\"]\n        )\n        pest_data.append({\n            \"common_name\": pest.common_name,\n            \"stages\": stages\n        })\n    frappe.response[\"data\"] = {\n        \"pests\": pest_data\n    }\n\nexcept Exception as e:\n    frappe.log_error(message=e, title=\"Get pests data error\")\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "createBedsAndZones",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.624945",
  "module": "Upande Scp",
  "name": "Zone Atomation Tool",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Bed And Zone Automation",
  "script": "def assign_variety_from_sectors(sectors, bed_number):\n    try:\n        bed_int = int(bed_number)\n    except Exception:\n        return None\n    for sector in sectors:\n        try:\n            if int(sector.from_bed) <= bed_int <= int(sector.to_bed):\n                return sector.sector\n        except Exception:\n            continue\n    return None\n\ndef safe_parse_json(json_string):\n    \"\"\"Parses a JSON string and handles potential errors gracefully.\"\"\"\n    if not json_string:\n        return {}\n    try:\n        return json.loads(json_string)\n    except json.JSONDecodeError as e:\n        frappe.throw(f\"Invalid JSON format: {e}\")\n    except Exception as e:\n        frappe.throw(f\"Error parsing JSON: {e}\")\n\ndoc_name = frappe.form_dict.get(\"doc_name\")\ntry:\n    if not doc_name:\n        frappe.throw(\n            \"Error: Document name is missing. Please save the document and try again.\")\n\n    doc = frappe.get_doc(\"Bed And Zone Automation\", doc_name)\n    beds_created_count = 0\n    zones_created_count = 0\n    skipped_beds_count = 0\n    skipped_zones_count = 0\n\n    greenhouse = doc.name\n    zones_geojson = doc.zones_geojson or \"\"\n    sectors = doc.sectors or []\n\n    for line in zones_geojson.strip().splitlines():\n        if not line.strip():\n            continue\n\n        feature_collection = safe_parse_json(line)\n        if not feature_collection:\n            continue\n            \n        for feature in feature_collection.get(\"features\", []):\n            props = feature.get(\"properties\", {})\n            bed_number = str(props.get(\"line_id\"))\n            zone_number = str(props.get(\"zone_id\"))\n\n            if not bed_number or not zone_number:\n                continue\n\n            variety = assign_variety_from_sectors(sectors, bed_number)\n            \n            # --- Bed ---\n            existing_bed_name = frappe.db.exists({\n                \"doctype\": \"Bed\",\n                \"greenhouse\": greenhouse,\n                \"bed\": bed_number\n            })\n\n            bed_doc = None\n            if existing_bed_name:\n                skipped_beds_count = skipped_beds_count + 1\n                bed_doc = frappe.get_doc(\"Bed\", existing_bed_name)\n            else:\n                try:\n                    bed_doc = frappe.get_doc({\n                        \"doctype\": \"Bed\",\n                        \"greenhouse\": greenhouse,\n                        \"bed\": bed_number,\n                        \"variety\": variety or \"\"  # Ensure variety is an empty string if None\n                    })\n                    bed_doc.insert(ignore_permissions=True)\n                    beds_created_count = beds_created_count + 1\n                except Exception as e:\n                    frappe.log_error(f\"Failed to create Bed: {e}\", \"Bed And Zone Automation Error\")\n                    continue  # Skip to the next feature if bed creation fails\n\n            if not bed_doc:\n                continue\n\n            # --- Zone ---\n            existing_zone_name = frappe.db.exists({\n                \"doctype\": \"Zone\",\n                \"greenhouse\": greenhouse,\n                \"bed\": bed_doc.name,\n                \"zone\": zone_number\n            })\n\n            if existing_zone_name:\n                skipped_zones_count = skipped_zones_count + 1\n            else:\n                try:\n                    zone_doc = frappe.get_doc({\n                        \"doctype\": \"Zone\",\n                        \"greenhouse\": greenhouse,\n                        \"bed\": bed_doc.name,\n                        \"zone\": zone_number,\n                        \"raw_geojson\": line\n                    })\n                    zone_doc.insert(ignore_permissions=True)\n                    zones_created_count = zones_created_count + 1\n                except Exception as e:\n                    frappe.log_error(f\"Failed to create Zone: {e}\", \"Bed And Zone Automation Error\")\n\n    frappe.msgprint(\n        f\"{beds_created_count} beds created, {skipped_beds_count} skipped. \"\n        f\"{zones_created_count} zones created, {skipped_zones_count} skipped.\"\n    )\n\nexcept Exception as e:\n    frappe.throw(f\"Error in Bed & Zone Automation: {e}\")",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "getPlantDiseasesData",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.671053",
  "module": "Upande Scp",
  "name": "Get Plant Diseases Data",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "try:\n    plant_diseases = frappe.get_all(\n        \"Plant Disease\",\n        fields=[\"name\", \"common_name\"]\n    )\n    plant_disease_data = []\n    for plant_disease in plant_diseases:\n        stages = frappe.get_all(\n            \"Disease Stages\",\n            filters={\"parent\": plant_disease.name},\n            fields=[\"stage\", \"image\"]\n        )\n        plant_disease_data.append({\n            \"common_name\": plant_disease.common_name,\n            \"stages\": stages\n        })\n    frappe.response[\"data\"] = {\n        \"plant_diseases\": plant_disease_data\n    }\n\nexcept Exception as e:\n    frappe.log_error(message=e, title=\"Get plant diseases data error\")\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "getScoutingAnalysis",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.095596",
  "module": "Upande Scp",
  "name": "Get Scouting Analysis",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# Assuming this code runs directly within the Frappe/ERPNext context where 'frappe' is available.\n\ntry:\n    # ----------------------------------------------------\n    # 1. Input Validation and Data Fetch\n    # ----------------------------------------------------\n    date_str = frappe.form_dict.get(\"date\")\n\n    if not date_str:\n        frappe.response[\"data\"] = {\n            \"scouting_summary\": {},\n            \"scout_movement_timeline\": [],\n            \"scout_paths\": [],\n            \"all_zones_geojson\": []\n        }\n    \n    # Fetch all scouting entries, ordered by creation time\n    scouting_entries = frappe.get_all(\n        \"Scouting Entry\",\n        fields=[\"name\", \"scouts_name\", \"greenhouse\", \"bed\",\n                \"zone\", \"time_of_capture\", \"date_of_capture\", \"latitude\", \"longitude\", \"creation\"],\n        filters=[\n            [\"date_of_capture\", \"=\", date_str]\n        ],\n        order_by=\"creation asc\",\n        limit_page_length=None\n    )\n\n    # Fetch all zones (for the coverage overlay)\n    all_zones = frappe.get_all(\n        \"Zone\",\n        filters={\"raw_geojson\": [\"is\", \"set\"]},\n        fields=[\"name\", \"raw_geojson\"]\n    )\n\n    # Initialize data structures\n    scouting_summary = {\n        \"total_unique_scouts\": 0,\n        \"total_beds_covered\": 0,\n        \"average_zones_per_bed\": 0,\n        \"average_minutes_per_bed\": 0 # Placeholder, calculation needs time parsing\n    }\n    scout_paths_list_final = []\n    scout_movement_timeline = []\n\n    if not scouting_entries:\n        frappe.response[\"data\"] = {\n            \"scouting_summary\": scouting_summary,\n            \"scout_movement_timeline\": [],\n            \"scout_paths\": [],\n            \"all_zones_geojson\": all_zones\n        }\n    else:\n        # ----------------------------------------------------\n        # 2. Employee Mapping and CRITICAL Name Replacement\n        # ----------------------------------------------------\n        \n        # 2a. Build Employee Map (ID -> Name)\n        unique_scout_ids = {entry.get(\"scouts_name\") for entry in scouting_entries if entry.get(\"scouts_name\")}\n\n        employee_map = {}\n        if unique_scout_ids:\n            employees = frappe.get_all(\n                \"Employee\",\n                filters={\"name\": (\"in\", list(unique_scout_ids))},\n                fields=[\"name\", \"employee_name\"]\n            )\n            employee_map = {emp.get(\"name\"): emp.get(\"employee_name\") for emp in employees}\n        \n        \n        # 2b. CRITICAL FIX: Replace ID with Name IN-PLACE on the raw data list.\n        for entry in scouting_entries:\n            raw_id = entry.get(\"scouts_name\")\n            if raw_id:\n                # Replace the ID with the human name; fallback to the original ID if not found\n                entry[\"scouts_name\"] = employee_map.get(raw_id, raw_id) \n                \n        # --- `scouting_entries` now uses the human name as the scout identifier ---\n\n        \n        # 2c. Build Path and Session Data using the now-fixed 'scouts_name'\n        scout_paths_points_final = {}\n        scout_greenhouse_sessions = {}\n\n        for record in scouting_entries:\n            canonical_scout_name = record.get(\"scouts_name\")\n            \n            if not canonical_scout_name: \n                continue \n\n            greenhouse = record.get(\"greenhouse\")\n            time_of_capture = record.get(\"time_of_capture\")\n\n            # --- Coordinate Extraction (FIXED FOR SIMULATED DATA) ---\n            latitude = record.get(\"latitude\")\n            longitude = record.get(\"longitude\")\n            \n            # Use string stripping and type check to avoid ValueError on empty strings/None\n            if latitude and longitude and str(latitude).strip() and str(longitude).strip():\n                try:\n                    lat_float = float(latitude)\n                    lon_float = float(longitude)\n                    \n                    # Ensure coordinates are not the invalid GPS fallback (0,0)\n                    if lat_float == 0.0 and lon_float == 0.0:\n                         continue # Skip this point\n                    \n                    if canonical_scout_name not in scout_paths_points_final:\n                        scout_paths_points_final[canonical_scout_name] = []\n                    \n                    # Store point under the Canonical Name\n                    scout_paths_points_final[canonical_scout_name].append({\n                        \"lat\": lat_float,\n                        \"lon\": lon_float,\n                        \"sort_key\": str(record.get(\"creation\")) \n                    })\n                except ValueError:\n                    # Silently ignore records where coordinates are truly non-numeric/corrupt\n                    pass\n\n            # --- Session Grouping Logic ---\n            if greenhouse and time_of_capture is not None:\n                record[\"time_of_capture_dt\"] = time_of_capture \n                \n                if canonical_scout_name not in scout_greenhouse_sessions:\n                    scout_greenhouse_sessions[canonical_scout_name] = {}\n                if greenhouse not in scout_greenhouse_sessions[canonical_scout_name]:\n                    scout_greenhouse_sessions[canonical_scout_name][greenhouse] = []\n                scout_greenhouse_sessions[canonical_scout_name][greenhouse].append(record)\n\n\n        # ----------------------------------------------------\n        # 3. Final Path Aggregation\n        # ----------------------------------------------------\n        for scout_name, points_list in scout_paths_points_final.items():\n            \n            points_list.sort(key=lambda p: p[\"sort_key\"])\n            path_data = [[p[\"lat\"], p[\"lon\"]] for p in points_list]\n            \n            scout_paths_list_final.append({\n                \"name\": scout_name, \n                \"path\": path_data\n            })\n\n\n        # ----------------------------------------------------\n        # 4. Summary Calculations and Final Response Setting\n        # ----------------------------------------------------\n\n        overall_total_beds = 0\n        overall_total_zones = 0\n        \n        # Calculate summary using the consolidated data keys\n        for scout_name, greenhouses in scout_greenhouse_sessions.items():\n            for greenhouse_name, entries in greenhouses.items():\n                session_beds = {e['bed'] for e in entries}\n                total_session_beds = len(session_beds)\n                total_session_zones = sum(len({e['zone'] for e in entries if e['bed'] == bed}) for bed in session_beds)\n\n                overall_total_beds += total_session_beds\n                overall_total_zones += total_session_zones\n\n        scouting_summary[\"total_unique_scouts\"] = len(scout_greenhouse_sessions)\n        scouting_summary[\"total_beds_covered\"] = overall_total_beds\n        scouting_summary[\"average_zones_per_bed\"] = overall_total_zones / \\\n            overall_total_beds if overall_total_beds > 0 else 0\n\n\n        # Set the final response data\n        frappe.response[\"data\"] = {\n            \"scouting_summary\": scouting_summary,\n            \"scouting_entries\": scouting_entries, # CONTAINS HUMAN NAMES\n            \"scout_movement_timeline\": scout_movement_timeline,\n            \"scout_paths\": scout_paths_list_final, # CONTAINS FULL PATH DATA (if GPS is valid)\n            \"all_zones_geojson\": all_zones\n        }\n\nexcept Exception as e:\n    # Set error response data\n    frappe.response[\"data\"] = {\n        \"error\": \"Error fetching scouting analysis. Script failed.\",\n        \"details\": str(e)\n    }\n# The function completes and Frappe handles frappe.response.",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "createScoutingEntry",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.414740",
  "module": "Upande Scp",
  "name": "Create Scouting Entry",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "try:\n    data = frappe.request.get_json()\n    if not data:\n        frappe.throw(_(\"Scouting data is missing from the request body.\"))\n\n    if isinstance(data, dict):\n        data_list = [data]\n    elif isinstance(data, list):\n        data_list = data\n    else:\n        frappe.throw(_(\"Expected a single scouting entry or a list of entries.\"))\n\n    results = []\n\n    for entry_data in data_list:\n        try:\n            duplicate_entry = frappe.db.exists(\n                \"Scouting Entry\", {\n                    \"scouts_name\": entry_data.get('scouts_name'),\n                    \"greenhouse\": entry_data.get('greenhouse'),\n                    \"bed\": entry_data.get('bed'),\n                    \"zone\": entry_data.get('zone'),\n                    \"date_of_capture\": entry_data.get('date_of_capture'),\n                    \"time_of_capture\": entry_data.get('time_of_capture')\n                }\n            )\n\n            if duplicate_entry:\n                results.append({\n                    \"status\": \"error\",\n                    \"message\": \"Duplicate scouting entry found for this scout, greenhouse, bed, zone, and time.\"\n                })\n                continue\n\n            scout_doc = frappe.new_doc(\"Scouting Entry\")\n            scout_doc.scouts_name = entry_data.get('scouts_name')\n            scout_doc.greenhouse = entry_data.get('greenhouse')\n            scout_doc.bed = entry_data.get('bed')\n            scout_doc.zone = entry_data.get('zone')\n            scout_doc.time_of_capture = entry_data.get('time_of_capture')\n            scout_doc.date_of_capture = entry_data.get('date_of_capture')\n            scout_doc.latitude = entry_data.get('latitude')\n            scout_doc.longitude = entry_data.get('longitude')\n            \n            def add_child_items(parent_doc, parent_field, items_list):\n                if items_list and isinstance(items_list, list):\n                    for item in items_list:\n                        if not item:\n                            continue\n\n                        child_row = parent_doc.append(parent_field, {})\n                        \n                        if parent_field == \"predators_scouting_entry\":\n                            child_row.plant_section = item.get(\"plant_section\")\n                            child_row.predator = item.get(\"predator\")\n                            child_row.stage = item.get(\"stage\")\n                            child_row.count = item.get(\"count\")\n                        \n                        elif parent_field == \"diseases_scouting_entry\":\n                            child_row.plant_section = item.get(\"plant_section\")\n                            child_row.disease = item.get(\"disease\")\n                            child_row.count = item.get(\"count\")\n                            child_row.stage = item.get(\"stage\")\n                            \n                        elif parent_field == \"physiological_disorders_entry\":\n                            child_row.plant_section = item.get(\"plant_section\")\n                            child_row.physiological_disorders = item.get(\"disorder\")\n\n                        elif parent_field == \"weeds_scouting_entry\":\n                            child_row.weed = item.get(\"weed\")\n\n                        elif parent_field == \"pests_scouting_entry\":\n                            child_row.plant_section = item.get(\"plant_section\")\n                            child_row.pest = item.get(\"pest\")\n                            child_row.stage = item.get(\"stage\")\n                            child_row.count = item.get(\"count\")\n\n                        elif parent_field == \"incidents_scouting_entry\":\n                            child_row.incident = item.get(\"incident\")\n\n            add_child_items(scout_doc, \"predators_scouting_entry\", entry_data.get(\"predators_scouting_entry\"))\n            add_child_items(scout_doc, \"diseases_scouting_entry\", entry_data.get(\"diseases_scouting_entry\"))\n            add_child_items(scout_doc, \"physiological_disorders_entry\", entry_data.get(\"physiological_disorders_entry\"))\n            add_child_items(scout_doc, \"weeds_scouting_entry\", entry_data.get(\"weeds_scouting_entry\"))\n            add_child_items(scout_doc, \"pests_scouting_entry\", entry_data.get(\"pests_scouting_entry\"))\n            add_child_items(scout_doc, \"incidents_scouting_entry\", entry_data.get(\"incidents_scouting_entry\"))\n\n            scout_doc.insert()\n            frappe.db.commit()\n\n            results.append({\n                \"status\": \"success\",\n                \"message\": \"Scouting Entry created successfully.\",\n                \"name\": scout_doc.name\n            })\n\n        except Exception as e:\n            frappe.db.rollback()\n            results.append({\n                \"status\": \"error\",\n                \"message\": str(e)\n            })\n    \n    frappe.response[\"data\"] = results\n\nexcept Exception as e:\n    frappe.response[\"data\"] = str(e)",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "getPanoramaAnalysis",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.541501",
  "module": "Upande Scp",
  "name": "Get Panorama Analysis",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "try:\n    date_str = frappe.form_dict.get(\"date\")\n    if not date_str:\n        frappe.throw(\"The date is required.\")\n\n    # Step 1: Fetch all pests and their associated data (stages, severity)\n    all_pests_names = frappe.get_all(\"Pest\", fields=[\"name\", \"pests_legend_color\"])\n    pest_name_list = [p.name for p in all_pests_names]\n\n    all_severities = frappe.get_all(\n        \"Scouting Severity Scale\",\n        filters={\"parent\": [\"in\", pest_name_list]},\n        fields=[\"parent\", \"from\", \"to\", \"color\"]\n    )\n\n    all_stages = frappe.get_all(\n        \"Pests Stages\",\n        filters={\"parent\": [\"in\", pest_name_list]},\n        fields=[\"parent\", \"stage\", \"symbol\"]\n    )\n\n    # Build a comprehensive pests map in memory\n    pests_map = {p.name: {\"severity\": [], \"stages\": [], \"pests_legend_color\": p.pests_legend_color} for p in all_pests_names}\n    for severity in all_severities:\n        pests_map[severity.parent][\"severity\"].append(severity)\n    for stage in all_stages:\n        pests_map[stage.parent][\"stages\"].append(stage)\n\n    # Step 2: Fetch all Scouting Entries and their pest data\n    scouting_entries = frappe.get_all(\n        \"Scouting Entry\",\n        filters=[[\"date_of_capture\", \"=\", date_str]],\n        fields=[\"name\", \"greenhouse\", \"bed\", \"zone\", \"latitude\", \"longitude\"],\n        order_by=\"time_of_capture asc\"\n    )\n\n    entry_names = [entry.name for entry in scouting_entries]\n    all_pest_entries = frappe.get_all(\n        \"Pests Scouting Entry\",\n        filters={\"parent\": [\"in\", entry_names]},\n        fields=[\"parent\", \"pest\", \"count\", \"stage\"]\n    )\n\n    # Build a map of pest entries keyed by their parent scouting entry\n    pest_entries_by_parent = {}\n    for pest_entry in all_pest_entries:\n        parent = pest_entry.parent\n        if parent not in pest_entries_by_parent:\n            pest_entries_by_parent[parent] = []\n        pest_entries_by_parent[parent].append(pest_entry)\n\n    # Step 3: Iterate through scouting entries and attach processed pest data\n    for entry in scouting_entries:\n        pest_entries = pest_entries_by_parent.get(entry.name, [])\n        processed_pests = []\n        for pest_entry in pest_entries:\n            pest_name = pest_entry.pest\n            pest_count = pest_entry.count\n            \n            pest_info = pests_map.get(pest_name)\n            if pest_info:\n                stage_symbol = \"‚ùì\"\n                if pest_entry.stage and pest_info[\"stages\"]:\n                    for stage in pest_info[\"stages\"]:\n                        if stage.get(\"stage\") == pest_entry.stage:\n                            stage_symbol = stage.get(\"symbol\")\n                            break\n                \n                severity_color = \"#cccccc\"\n                if pest_info[\"severity\"]:\n                    for severity in pest_info[\"severity\"]:\n                        if severity.get(\"from\") <= pest_count <= severity.get(\"to\"):\n                            severity_color = severity.get(\"color\")\n                            break\n                \n                processed_pests.append({\n                    \"pest\": pest_name,\n                    \"count\": pest_count,\n                    \"symbol\": stage_symbol,\n                    \"color\": severity_color\n                })\n        entry[\"pests_scouting_entry\"] = processed_pests\n\n    # Step 4: Fetch all zones with geojson data in a single query\n    all_zones = frappe.get_all(\n        \"Zone\",\n        filters={\"raw_geojson\": [\"is\", \"set\"]},\n        fields=[\"name\", \"raw_geojson\"]\n    )\n\n    frappe.response[\"data\"] = {\n        \"scouting_entries\": scouting_entries,\n        \"all_zones_geojson\": all_zones,\n        \"all_pests_names\": all_pests_names\n    }\n    \nexcept Exception as e:\n        frappe.throw(\"Error fetching panorama analysis: \" + str(e))",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "getBedsAndZones",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.586818",
  "module": "Upande Scp",
  "name": "Beds & Zones",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "try:\n    # Get all beds\n    beds = frappe.get_all(\"Bed\", fields=[\"name\", \"variety\"])\n\n    # Get all zones (with bed reference)\n    zones = frappe.get_all(\n        \"Zone\",\n        filters={\"raw_geojson\": [\"is\", \"set\"]},\n        fields=[\"name\", \"raw_geojson\", \"bed\"]\n    )\n\n    # Map zones to their beds\n    bed_map = {b[\"name\"]: {**b, \"zones\": []} for b in beds}\n    for z in zones:\n        if z[\"bed\"] in bed_map:\n            bed_map[z[\"bed\"]][\"zones\"].append({\n                \"name\": z[\"name\"],\n                \"raw_geojson\": z[\"raw_geojson\"]\n            })\n\n    # Group beds by variety\n    variety_map = {}\n    for bed in bed_map.values():\n        variety = bed[\"variety\"]\n        if variety not in variety_map:\n            variety_map[variety] = {\"variety\": variety, \"beds\": []}\n        variety_map[variety][\"beds\"].append({\n            \"name\": bed[\"name\"],\n            \"zones\": bed[\"zones\"]\n        })\n\n    # Final structured response\n    frappe.response[\"data\"] = list(variety_map.values())\n\nexcept Exception as e:\n    frappe.throw(\"Error fetching panorama analysis: \" + str(e))\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "getScoutingData",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:29.956148",
  "module": "Upande Scp",
  "name": "Get Scouting Data",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "try:\n    greenhouse = frappe.form_dict.get(\"greenhouse\")\n    # date = \"2025-09-18\"\n    date = frappe.form_dict.get(\"date\")\n    if not greenhouse or not date:\n        frappe.throw(\"Greenhouse and date are required.\")\n\n    pest_names = frappe.get_all(\"Pest\", fields=[\"name\"])\n    pest_name_list = [p.name for p in pest_names]\n\n    all_severities = frappe.get_all(\n        \"Scouting Severity Scale\",\n        filters={\"parent\": [\"in\", pest_name_list]},\n        fields=[\"parent\", \"from\", \"to\", \"color\"]\n    )\n\n    all_stages = frappe.get_all(\n        \"Pests Stages\",\n        filters={\"parent\": [\"in\", pest_name_list]},\n        fields=[\"parent\", \"stage\", \"symbol\"]\n    )\n\n    pests_map = {p.name: {\"severity\": [], \"stages\": []} for p in pest_names}\n\n    for severity in all_severities:\n        pests_map[severity.parent][\"severity\"].append(severity)\n\n    for stage in all_stages:\n        pests_map[stage.parent][\"stages\"].append(stage)\n\n    scouting_entries = frappe.get_all(\n        \"Scouting Entry\",\n        fields=[\"name\", \"bed\", \"zone\"],\n        filters=[\n            [\"greenhouse\", \"=\", greenhouse],\n            [\"date_of_capture\", \"=\", date]\n        ]\n    )\n\n    entry_names = [entry.name for entry in scouting_entries]\n\n    all_pest_entries = frappe.get_all(\n        \"Pests Scouting Entry\",\n        filters={\"parent\": [\"in\", entry_names]},\n        fields=[\"parent\", \"pest\",\"plant_section\", \"count\", \"stage\"]\n    )\n\n    pest_entries_by_parent = {}\n    for pest_entry in all_pest_entries:\n        parent = pest_entry.parent\n        if parent not in pest_entries_by_parent:\n            pest_entries_by_parent[parent] = []\n        pest_entries_by_parent[parent].append(pest_entry)\n\n    for entry in scouting_entries:\n        pest_entries = pest_entries_by_parent.get(entry.name, [])\n        processed_pests = []\n        for pest_entry in pest_entries:\n            pest_name = pest_entry.pest\n            plant_section=pest_entry.plant_section\n            pest_count = pest_entry.count\n            pest_stage = pest_entry.stage\n            \n            \n\n            pest_info = pests_map.get(pest_name)\n\n            stage_symbol = None\n            severity_color = None\n\n            if pest_info:\n                # Corrected: Use bracket notation for the list of stages\n                if pest_entry.stage and pest_info.get(\"stages\"):\n                    # Corrected: Use bracket notation for the stage property\n                    for stage in pest_info[\"stages\"]:\n                        if stage.get(\"stage\") == pest_entry.stage:\n                            stage_symbol = stage.get(\"symbol\")\n                            break\n\n                # Corrected: Use bracket notation for the list of severity levels\n                if pest_info.get(\"severity\"):\n                    # Corrected: Use bracket notation for the color property\n                    for severity in pest_info[\"severity\"]:\n                        if severity.get(\"from\") <= pest_count <= severity.get(\"to\"):\n                            severity_color = severity.get(\"color\")\n                            break\n\n            processed_pests.append({\n                \"pest\": pest_name,\n                \"plant_section\":plant_section,\n                \"count\": pest_count,\n                \"symbol\": stage_symbol,\n                \"color\": severity_color,\n                \"stage\": pest_stage\n            })\n\n        entry[\"pests_scouting_entry\"] = processed_pests\n\n    varieties_planted_in_gh = frappe.get_all(\n        \"Items Greenhouses\",\n        filters={\"parent\": greenhouse},\n        fields=[\"variety\"]\n    )\n\n    variety_names = [\n        variety_doc.variety for variety_doc in varieties_planted_in_gh]\n\n    all_thresholds = frappe.get_all(\n        \"Chemical Requirements\",\n        filters=[[\"parent\", \"in\", variety_names]],\n        fields=[\"parent\", \"scope\", \"low\", \"moderate\", \"high\"]\n    )\n\n    thresholds_by_variety = {}\n    for threshold in all_thresholds:\n        parent = threshold.parent\n        if parent not in thresholds_by_variety:\n            thresholds_by_variety[parent] = []\n        thresholds_by_variety[parent].append({\n            \"scope\": threshold.scope,\n            \"low\": threshold.low,\n            \"moderate\": threshold.moderate,\n            \"high\": threshold.high\n        })\n\n    varieties_data = []\n    for variety_name in variety_names:\n        thresholds = thresholds_by_variety.get(variety_name, [])\n        varieties_data.append({\n            \"name\": variety_name,\n            \"thresholds\": thresholds\n        })\n\n    chemical_mix_boms = frappe.get_all(\n    \"BOM\",\n    filters={\n        \"custom_item_group\": \"Chemical Mix\",\n        \"docstatus\": 1,\n        \"is_active\": 1\n    },\n    fields=[\"name\", \"custom_water_ph\", \"custom_water_hardness\"]\n    )\n\n    bom_names = [bom[\"name\"] for bom in chemical_mix_boms]\n\n    bom_items = frappe.db.get_all(\n        \"BOM Item\",\n        filters={\"parent\": [\"in\", bom_names]},\n        fields=[\"parent\", \"item_name\", \"qty\", \"uom\"]\n    )\n\n    bed_zone_numbering = frappe.get_all(\n        \"Warehouse\",\n        filters={\"name\": greenhouse},\n        fields=[\"name\", \"custom_bed_numbering\", \"custom_zone_numbering\"]\n    )\n\n    chemicals = frappe.db.get_list(\n        'Item',\n        filters={\n            'item_group': 'CHEMICALS',\n        },\n        fields=['item_name']\n    )\n\n    uoms = frappe.db.get_list(\n        'UOM',\n        fields=['name']\n    )\n\n    all_chemicals = set()\n    for item in chemicals:\n        all_chemicals.add(item.item_name)\n\n    all_uoms = set()\n    for uom in uoms:\n        all_uoms.add(uom.name)\n\n    bed_data = frappe.get_all(\n        \"Bed\",\n        filters={\"greenhouse\": greenhouse},\n        fields=[\"greenhouse\", \"bed\", \"bed__area\",\n                \"total_variety_area\", \"variety\"]\n    )\n\n    spray_teams = frappe.get_all(\n        \"Spray Team\",\n        filters={\"enabled\": 1},\n        fields=[\"name\"]\n    )\n   \n    frappe.response[\"data\"] = {\n        \"scouting_entries\": scouting_entries,\n        \"varieties\": varieties_data,\n        \"boms\": chemical_mix_boms,\n        \"bom_items\": bom_items,\n        \"bed_zone_numbering\": bed_zone_numbering,\n        \"all_chemicals\": sorted(list(all_chemicals)),\n        \"all_uoms\": sorted(list(all_uoms)),\n        \"bed_data\": bed_data,\n        \"spray_team_team\": spray_teams\n    }\n\nexcept Exception as e:\n    frappe.log_error(title=\"Server Script Error\", message=str(e))\n    frappe.throw(\"Error fetching scouting data: \" + str(e))\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "createChemicalPlanWorkOrder",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.139197",
  "module": "Upande Scp",
  "name": "Create Chemical Plan Work Order",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "try:\n    bom_name = frappe.form_dict.get(\"production_item\")\n    if not bom_name:\n        frappe.msgprint(\"BOM name is a required field.\")\n    else:\n        bom_doc = frappe.get_doc(\"BOM\", bom_name)\n        production_item = bom_doc.get(\"item\")\n\n        if not production_item:\n            frappe.msgprint(\n                \"The selected BOM does not have a defined production item.\")\n        else:\n            area = frappe.form_dict.get(\"custom_area\")\n            greenhouse = frappe.form_dict.get(\"custom_greenhouse\")\n            spray_team = frappe.form_dict.get(\"custom_spray_team\")\n\n            spray_team_doc = frappe.get_doc(\"Spray Team\", spray_team)\n            team_members_data = spray_team_doc.get(\"team\")\n            employee_ids = []\n            name_lookup_map = {}\n\n            if team_members_data:\n                employee_ids = [member.get(\n                    'name1') for member in team_members_data if member.get('name1')]\n\n                employee_data = frappe.get_all(\n                    \"Employee\",\n                    filters={\"name\": [\"in\", employee_ids]},\n                    fields=[\"name\", \"employee_name\"]\n                )\n\n                name_lookup_map = {item['name']: item['employee_name'] for item in employee_data}\n\n\n            formatted_members = []\n            if team_members_data:\n                for member in team_members_data:\n                    employee_id = member.get('name1')\n                    role = member.get('role')\n\n                    display_name = name_lookup_map.get(\n                        employee_id, employee_id)\n\n                    if display_name and role:\n                        formatted_line = f\"{display_name} - {role}\"\n                        formatted_members.append(formatted_line)\n\n                spray_team_data = \"\\n\".join(formatted_members)\n\n            target_data_string = frappe.form_dict.get(\"custom_targets\")\n            target_list = []\n            if target_data_string:\n                target_list = json.loads(target_data_string)\n\n            formatted_targets = []\n            for target in target_list:\n                formatted_targets.append(target)\n            formatted_string = \"\\n\".join(formatted_targets)\n\n            work_order_doc = frappe.get_doc({\n                \"doctype\": \"Work Order\",\n                \"production_item\": production_item,\n                \"qty\": frappe.utils.cint(frappe.form_dict.get(\"qty\") or 1),\n                \"bom_no\": bom_name,\n                \"company\": \"Karen Roses\",\n                \"wip_warehouse\": \"Work In Progress - KR\",\n                \"fg_warehouse\": greenhouse,\n                \"custom_type\": frappe.form_dict.get(\"custom_type\"),\n                \"custom_greenhouse\": greenhouse,\n                \"custom_variety\": frappe.form_dict.get(\"custom_variety\"),\n                \"custom_targets\": formatted_string,\n                \"custom_spray_type\": frappe.form_dict.get(\"custom_spray_type\"),\n                \"custom_kit\": frappe.form_dict.get(\"custom_kit\"),\n                \"custom_scope\": frappe.form_dict.get(\"custom_scope\"),\n                \"custom_scope_details\": frappe.form_dict.get(\"custom_scope_details\"),\n                \"custom_water_ph\": frappe.form_dict.get(\"custom_water_ph\"),\n                \"custom_water_hardness\": frappe.form_dict.get(\"custom_water_hardness\"),\n                \"custom_water_volume\": frappe.form_dict.get(\"custom_water_volume\"),\n                \"custom_area\": area,\n                \"custom_spray_team\": spray_team_data\n            })\n            work_order_doc.insert()\n            frappe.db.commit()\n\n            new_work_order_doc = frappe.get_doc(\n                \"Work Order\", work_order_doc.name)\n\n            chemicals_data = frappe.form_dict.get(\"chemicals\")\n            if isinstance(chemicals_data, str):\n                chemicals_data = json.loads(chemicals_data)\n\n            chemical_names = [c.get(\"chemical\") for c in chemicals_data]\n            items_map = frappe.get_all(\n                \"Item\", filters={\"item_name\": [\"in\", chemical_names]}, fields=[\"item_name\", \"item_code\"]\n            )\n            item_name_to_code = {i[\"item_name\"]: i[\"item_code\"] for i in items_map}\n\n            existing_wo_item_codes = {\n                item.item_code for item in new_work_order_doc.required_items}\n\n            se_items = []\n            chemicals_to_add = []\n\n            for chem in chemicals_data:\n                chemical_name = chem.get(\"chemical\")\n                item_code = item_name_to_code.get(chemical_name)\n\n                if not item_code:\n                    frappe.throw(\n                        f\"Item not found for chemical: {chemical_name}\")\n\n                qty = float(chem.get(\"quantity\")) * float(area)\n                se_items.append({\n                    \"item_code\": item_code, \"qty\": qty, \"uom\": chem.get(\"uom\"),\n                    \"s_warehouse\": chem.get(\"source_warehouse\"), \"t_warehouse\": \"Work In Progress - KR\"\n                })\n\n                if item_code not in existing_wo_item_codes:\n                    chemicals_to_add.append({\n                        \"item_code\": item_code,\n                        \"source_warehouse\": chem.get(\"source_warehouse\"),\n                        \"uom\": chem.get(\"uom\"),\n                        \"calculated_qty\": qty\n                    })\n\n            se = frappe.get_doc({\n                \"doctype\": \"Stock Entry\",\n                \"stock_entry_type\": \"Material Transfer for Manufacture\",\n                \"company\": \"Karen Roses\",\n                \"purpose\": \"Material Transfer for Manufacture\",\n                \"custom_farm\": greenhouse.split()[0],\n                \"items\": se_items\n            })\n            se.insert(ignore_permissions=True)\n\n            se_item_rate_map = {item.item_code: item for item in se.items}\n\n            for chem_data in chemicals_to_add:\n                item_code = chem_data[\"item_code\"]\n                se_item = se_item_rate_map.get(item_code)\n\n                if se_item:\n                    fifo_rate = se_item.valuation_rate or se_item.basic_rate\n                    amount = chem_data[\"calculated_qty\"] * fifo_rate\n\n                    new_work_order_doc.append(\"required_items\", {\n                        \"item_code\": item_code,\n                        \"required_qty\": chem_data[\"calculated_qty\"],\n                        \"uom\": chem_data[\"uom\"],\n                        \"source_warehouse\": chem_data[\"source_warehouse\"],\n                        \"rate\": fifo_rate,\n                        \"amount\": amount\n                    })\n\n            for item_row in new_work_order_doc.required_items:\n                item_code = item_row.item_code\n                se_item = se_item_rate_map.get(item_code)\n\n                if se_item:\n                    original_chem_data = None\n                    for chem_data_item in chemicals_data:\n                        if item_name_to_code.get(chem_data_item.get('chemical')) == item_code:\n                            original_chem_data = chem_data_item\n                            break\n\n                    current_qty = float(item_row.required_qty or 0)\n                    calculated_qty = current_qty * float(area)\n\n                    fifo_rate = se_item.valuation_rate or se_item.basic_rate\n                    amount = calculated_qty * fifo_rate\n                    item_row.rate = fifo_rate\n                    item_row.amount = amount\n                    item_row.source_warehouse = se_item.s_warehouse\n\n                    if item_code in existing_wo_item_codes:\n                        item_row.required_qty = calculated_qty\n                        item_row.db_update()\n                    else:\n                        item_row.parent = new_work_order_doc.name\n                        item_row.required_qty = chem_data[\"calculated_qty\"]\n                        item_row.parenttype = \"Work Order\"\n                        item_row.db_insert()\n\n            se.delete()\n\n            frappe.db.commit()\n\n            frappe.msgprint(\n                f\"Work Order {work_order_doc.name} created successfully!\")\n\nexcept Exception as e:\n     frappe.log_error(\"Error\",str(e))\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "getBomStockBalances",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.500494",
  "module": "Upande Scp",
  "name": "Get BOM Stock Balances",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "try:\n    data = frappe.form_dict.get(\"data\")\n    item_names = []\n    if data:\n        item_names = json.loads(data).get(\"chemicals\", [])\n\n    item_code_map = {}\n    code_item_map = {}\n    item_uom_map = {}\n\n    if item_names:\n        items = frappe.get_list(\n            \"Item\",\n            filters={\"item_name\": (\"in\", item_names)},\n            fields=[\"item_name\", \"item_code\", \"stock_uom\"],\n            as_list=False\n        )\n        for item in items:\n            name = item.get(\"item_name\")\n            code = item.get(\"item_code\")\n            stock_uom = item.get(\"stock_uom\")\n            item_code_map[name] = code\n            code_item_map[code] = name\n            item_uom_map[name] = stock_uom\n\n    chemicals = list(item_code_map.values())\n\n    source_warehouses = [\n        'Chemical Store Chepsito - KR',\n        'Chemical Store Kapkolia - KR',\n        'Chemical Store Kaptumbo - KR',\n        'Chemical Store Simotwo - KR',\n        'Chemical Store Torongo - KR'\n    ]\n\n    code_stock_balances = {}\n    if chemicals:\n        bins = frappe.get_list(\n            \"Bin\",\n            filters={\n                \"item_code\": (\"in\", chemicals),\n                \"warehouse\": (\"in\", source_warehouses)\n            },\n            fields=[\"item_code\", \"warehouse\", \"actual_qty\"],\n            as_list=False\n        )\n\n        for chemical_code in chemicals:\n            code_stock_balances[chemical_code] = {}\n            for warehouse in source_warehouses:\n                code_stock_balances[chemical_code][warehouse] = 0.0\n\n        for bin_record in bins:\n            item_code = bin_record.get('item_code')\n            wh = bin_record.get('warehouse')\n            qty = bin_record.get('actual_qty')\n            if item_code in code_stock_balances and wh in code_stock_balances[item_code]:\n                code_stock_balances[item_code][wh] = qty\n\n    final_stock_balances = {}\n    for code, balances in code_stock_balances.items():\n        item_name = code_item_map.get(code)\n\n        if item_name:\n            final_stock_balances[item_name] = balances\n\n    frappe.response[\"data\"] = {\n        \"stock_balances\": final_stock_balances,\n        \"item_uom_map\": item_uom_map\n    }\n\nexcept Exception as e:\n    frappe.log_error(title=\"Server Script Error\", message=str(e))\n    frappe.throw(\"Error fetching stock balances: \" + str(e))\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "getReentryStatus",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.466335",
  "module": "Upande Scp",
  "name": "Get Greenhouse Reentry Status",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "greenhouse_name = frappe.form_dict.get('greenhouse')\ninput_date = frappe.form_dict.get('date')\n\nif not greenhouse_name or not input_date:\n    frappe.response['http_status_code'] = 400\n    frappe.response['message'] = \"Missing 'greenhouse' and/or 'date' parameter.\"\n    exit()\n\nfilters = [\n    [\"custom_greenhouse\", \"=\", greenhouse_name],\n    [\"docstatus\", \"=\", 1],\n    [\"custom_scheduled_application_time\", \">=\", input_date]\n]\n\nwork_orders = frappe.get_list(\n    doctype=\"Work Order\",\n    filters=filters,\n    fields=[\n        \"name\", \n        \"custom_scheduled_application_time\",\n        \"custom_reentry_time\"\n    ],\n    order_by=\"custom_scheduled_application_time asc\"\n)\n\nfrappe.response['data'] = work_orders",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "preValidateFracIracGuidelines",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.263331",
  "module": "Upande Scp",
  "name": "Pre-Validate Frac/Irac Guidelines",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# =================================================================================\n# --- HELPER FUNCTION: Get Rotation Codes and Type ---\n# =================================================================================\ndef get_item_rotation_codes(item_names, log_title):\n    \"\"\"\n    Fetches rotation codes (FRAC/IRAC) and custom_type for a list of items.\n    Returns: {item_name: {'type': 'Fungicide'/'Insecticide', 'FRAC': set(codes), 'IRAC': set(codes)}}\n    \"\"\"\n    if not item_names:\n        return {}\n    \n    # Fetch Item details by item_name (display name)\n    item_details = frappe.get_all(\n        \"Item\",\n        filters=[[\"Item\", \"item_name\", \"in\", list(item_names)]],\n        fields=[\"name\", \"item_name\", \"custom_type\"],\n        ignore_permissions=True\n    )\n    \n    if not item_details:\n        frappe.log_error(log_title, f\"WARNING: No items found for names: {list(item_names)}\")\n        return {name: {'type': None, 'FRAC': set(), 'IRAC': set()} for name in item_names}\n    \n    item_type_map = {d.item_name: d.custom_type for d in item_details}\n    parent_ids = [d.name for d in item_details]\n    id_to_item_name = {d.name: d.item_name for d in item_details}\n    \n    # Fetch FRAC codes\n    frac_data = frappe.db.get_list(\n        \"FRAC Code Filter\",\n        filters={\"parenttype\": \"Item\", \"parentfield\": \"custom_frac\", \"parent\": [\"in\", parent_ids]},\n        fields=[\"parent\", \"code\"],\n        ignore_permissions=True\n    )\n    \n    # Fetch IRAC codes\n    irac_data = frappe.db.get_list(\n        \"IRAC Code Filter\",\n        filters={\"parenttype\": \"Item\", \"parentfield\": \"custom_irac\", \"parent\": [\"in\", parent_ids]},\n        fields=[\"parent\", \"code\"],\n        ignore_permissions=True\n    )\n    \n    # Build result map\n    item_rotation_code_map = {}\n    for item_name in item_names:\n        item_rotation_code_map[item_name] = {\n            'type': item_type_map.get(item_name),\n            'FRAC': set(), \n            'IRAC': set()\n        }\n    \n    for row in frac_data:\n        item_name = id_to_item_name.get(row.parent)\n        if item_name:\n            item_rotation_code_map[item_name]['FRAC'].add(row.code)\n    \n    for row in irac_data:\n        item_name = id_to_item_name.get(row.parent)\n        if item_name:\n            item_rotation_code_map[item_name]['IRAC'].add(row.code)\n    \n    return item_rotation_code_map\n\n\n# =================================================================================\n# --- VALIDATION 1: KNOWN RESISTANCE ---\n# =================================================================================\ndef validate_known_resistance_frac(current_targets, item_name, frac_codes):\n    guideline_name = \"Targets With Known Resistance\"\n    validation_errors = []\n\n    try:\n        guideline_doc = frappe.get_doc(\"FRAC Guideline\", guideline_name)\n    except frappe.DoesNotExistError:\n        return [f\"ERROR: FRAC Guideline '{guideline_name}' not found.\"]\n\n    if not guideline_doc.enabled:\n        return []\n    \n    if not guideline_doc.parameter_coding or not guideline_doc.parameters:\n        return [f\"ERROR: Missing setup in FRAC Guideline '{guideline_name}'.\"]\n    \n    # Parse resistance rules: {TargetPest: set(ResistantCodes)}\n    resistance_rules = {}\n    try:\n        keys = guideline_doc.parameter_coding.strip().split(\":\")\n        rule_strings = guideline_doc.parameters.strip().split('\\n')\n        \n        for rule_string in rule_strings:\n            rule_string = rule_string.strip()\n            if not rule_string:\n                continue\n            \n            values = rule_string.split(\":\")\n            if len(keys) != len(values):\n                continue\n            \n            params = dict(zip(keys, values))\n            target_pest = params.get(\"TargetPest\", \"\").strip()\n            codes_str = params.get(\"ResistantFracCodes\", \"\").strip()\n            \n            if target_pest and codes_str:\n                resistance_rules[target_pest] = {c.strip() for c in codes_str.split(',') if c.strip()}\n    except Exception as e:\n        return [f\"CRITICAL ERROR during FRAC rule parsing: {e}\"]\n    \n    # Check for violations\n    for target in current_targets:\n        if target in resistance_rules:\n            resistant_codes = resistance_rules[target]\n            violating_codes = frac_codes.intersection(resistant_codes)\n            \n            if violating_codes:\n                validation_errors.append(\n                    f\"Item {item_name} has known resistance to FRAC code(s): {', '.join(violating_codes)} for target '{target}'.\"\n                )\n    \n    return validation_errors\n\n\ndef validate_known_resistance_irac(current_targets, item_name, irac_codes):\n    guideline_name = \"Targets With Known Resistance\"\n    validation_errors = []\n\n    try:\n        guideline_doc = frappe.get_doc(\"IRAC Guideline\", guideline_name)\n    except frappe.DoesNotExistError:\n        return [f\"ERROR: IRAC Guideline '{guideline_name}' not found.\"]\n\n    if not guideline_doc.enabled:\n        return []\n    \n    if not guideline_doc.parameter_coding or not guideline_doc.parameters:\n        return [f\"ERROR: Missing setup in IRAC Guideline '{guideline_name}'.\"]\n    \n    # Parse resistance rules: {TargetPest: set(ResistantCodes)}\n    resistance_rules = {}\n    try:\n        keys = guideline_doc.parameter_coding.strip().split(\":\")\n        rule_strings = guideline_doc.parameters.strip().split('\\n')\n        \n        for rule_string in rule_strings:\n            rule_string = rule_string.strip()\n            if not rule_string:\n                continue\n            \n            values = rule_string.split(\":\")\n            if len(keys) != len(values):\n                continue\n            \n            params = dict(zip(keys, values))\n            target_pest = params.get(\"Target\", params.get(\"TargetPest\", \"\")).strip()\n            \n            # Find code key\n            code_key = 'IracCode'\n            for k in keys:\n                if 'IracCode' in k or 'Code' in k:\n                    code_key = k\n                    break\n            codes_str = params.get(code_key, \"\").strip()\n            \n            if target_pest and codes_str:\n                resistance_rules[target_pest] = {c.strip() for c in codes_str.split(',') if c.strip()}\n    except Exception as e:\n        return [f\"CRITICAL ERROR during IRAC rule parsing: {e}\"]\n    \n    # Check for violations\n    for target in current_targets:\n        if target in resistance_rules:\n            resistant_codes = resistance_rules[target]\n            violating_codes = irac_codes.intersection(resistant_codes)\n            \n            if violating_codes:\n                validation_errors.append(\n                    f\"Item {item_name} has known resistance to IRAC code(s): {', '.join(violating_codes)} for target '{target}'.\"\n                )\n    \n    return validation_errors\n\n\ndef validate_known_resistance_router(data, item_rotation_map, current_targets):\n    all_errors = []\n    \n    for item_name, item_data in item_rotation_map.items():\n        item_type = item_data.get('type')\n        \n        if item_type == 'Fungicide':\n            errors = validate_known_resistance_frac(current_targets, item_name, item_data.get('FRAC', set()))\n            all_errors.extend(errors)\n        elif item_type == 'Insecticide':\n            errors = validate_known_resistance_irac(current_targets, item_name, item_data.get('IRAC', set()))\n            all_errors.extend(errors)\n    \n    return all_errors\n\n\n# =================================================================================\n# --- VALIDATION 2: ALTERNATE MOA ---\n# =================================================================================\ndef validate_alternate_moa_rotation(data, item_rotation_map, code_type):\n    guideline_name = \"Alternate MoA\"\n    guideline_doctype = f\"{code_type.upper()} Guideline\"\n    \n    try:\n        guideline_doc = frappe.get_doc(guideline_doctype, guideline_name)\n    except frappe.DoesNotExistError:\n        return [f\"ERROR: {guideline_doctype} '{guideline_name}' not found.\"]\n    \n    if not guideline_doc.enabled:\n        return []\n    \n    # Get allowed codes from guideline\n    allowed_codes = {item.code for item in guideline_doc.get(f\"{code_type.lower()}_code_filter\", [])}\n    if not allowed_codes:\n        return []\n    \n    current_greenhouse = data.get(\"custom_greenhouse\")\n    current_date = frappe.utils.getdate(data.get(\"custom_scheduled_application_time\"))\n    \n    try:\n        max_consecutive = int(guideline_doc.parameters.strip())\n        look_back_limit = max_consecutive * 2\n    except ValueError:\n        return [f\"ERROR: Invalid Max Consecutive Usage for {code_type.upper()} '{guideline_name}'.\"]\n    \n    # Get current application codes\n    current_codes = set()\n    for item_name, item_data in item_rotation_map.items():\n        if item_data.get('type', '').upper().startswith(code_type.upper()):\n            current_codes.update(item_data[code_type.upper()].intersection(allowed_codes))\n    \n    if not current_codes:\n        return []\n    \n    # Get historical work orders\n    historical_wos = frappe.get_all(\n        \"Work Order\",\n        filters={\n            \"custom_greenhouse\": current_greenhouse,\n            \"docstatus\": 1,\n            \"custom_scheduled_application_time\": (\"<\", current_date),\n            \"custom_type\": \"Application Floor Plan\"\n        },\n        fields=[\"name\", \"custom_scheduled_application_time\"],\n        order_by=\"custom_scheduled_application_time desc\",\n        limit=look_back_limit,\n        ignore_permissions=True\n    )\n    \n    if not historical_wos:\n        return []\n    \n    historical_wo_names = [wo.name for wo in historical_wos]\n    \n    # Get historical items\n    historical_items = frappe.get_all(\n        \"Work Order Item\",\n        filters={\"parent\": [\"in\", historical_wo_names], \"parenttype\": \"Work Order\"},\n        fields=[\"item_code\", \"parent\"],\n        ignore_permissions=True\n    )\n    \n    historical_item_codes = {item.item_code for item in historical_items}\n    historical_rotation_map = get_item_rotation_codes(historical_item_codes, f\"{code_type} Alternate MoA\")\n    \n    # Map historical WO to codes\n    historical_wo_codes = {}\n    for record in historical_items:\n        item_data = historical_rotation_map.get(record.item_code, {})\n        if item_data.get('type', '').upper().startswith(code_type.upper()):\n            codes = item_data.get(code_type.upper(), set()).intersection(allowed_codes)\n            historical_wo_codes[record.parent] = historical_wo_codes.get(record.parent, set()).union(codes)\n    \n    # Check consecutive usage\n    validation_errors = []\n    wo_order = [wo.name for wo in historical_wos]\n    \n    for current_code in current_codes:\n        consecutive_count = 1\n        \n        for wo_name in wo_order:\n            if current_code in historical_wo_codes.get(wo_name, set()):\n                consecutive_count += 1\n            else:\n                break\n        \n        if consecutive_count > max_consecutive:\n            validation_errors.append(\n                f\"{code_type.upper()} Code {current_code} has been applied {consecutive_count} consecutive times, exceeding the limit of {max_consecutive}.\"\n            )\n    \n    return validation_errors\n\n\n# =================================================================================\n# --- VALIDATION 3: MAX NUMBER OF SPRAYS ---\n# =================================================================================\ndef validate_max_sprays(data, item_rotation_map, code_type):\n    guideline_name = \"Max Number Of Sprays\"\n    guideline_doctype = f\"{code_type.upper()} Guideline\"\n    \n    try:\n        guideline_doc = frappe.get_doc(guideline_doctype, guideline_name)\n    except frappe.DoesNotExistError:\n        return [f\"ERROR: {guideline_doctype} '{guideline_name}' not found.\"]\n    \n    if not guideline_doc.enabled:\n        return []\n    \n    # Get allowed codes\n    allowed_codes = {item.code for item in guideline_doc.get(f\"{code_type.lower()}_code_filter\", [])}\n    \n    current_greenhouse = data.get(\"custom_greenhouse\")\n    current_date = frappe.utils.getdate(data.get(\"custom_scheduled_application_time\"))\n    \n    # Parse rules\n    keys = guideline_doc.parameter_coding.split(\":\")\n    rule_strings = guideline_doc.parameters.strip().split('\\n')\n    \n    max_break_days = 0\n    parsed_rules = []\n    \n    for rule_string in rule_strings:\n        rule_string = rule_string.strip()\n        if not rule_string:\n            continue\n        \n        values = rule_string.split(\":\")\n        if len(keys) != len(values):\n            continue\n        \n        params = dict(zip(keys, values))\n        \n        try:\n            chemical = params.get(\"Chemical\")\n            max_sprays = int(str(params.get(\"Sprays\", \"\")).strip())\n            break_days = int(str(params.get(\"RequiredBreakInDays\", \"\")).strip())\n        except Exception:\n            continue\n        \n        max_break_days = max(max_break_days, break_days)\n        parsed_rules.append({\"chemical\": chemical, \"max_sprays\": max_sprays, \"break_days\": break_days})\n    \n    if not parsed_rules:\n        return []\n    \n    lookback_date = frappe.utils.add_days(current_date, -max_break_days)\n    \n    # Get historical work orders\n    historical_wos = frappe.get_all(\n        \"Work Order\",\n        filters={\n            \"custom_greenhouse\": current_greenhouse,\n            \"docstatus\": 1,\n            \"custom_scheduled_application_time\": (\">=\", lookback_date),\n            \"custom_type\": \"Application Floor Plan\"\n        },\n        fields=[\"name\", \"custom_scheduled_application_time\"],\n        ignore_permissions=True\n    )\n    \n    wo_dates = {wo.name: frappe.utils.getdate(wo.custom_scheduled_application_time) for wo in historical_wos}\n    wo_names = [wo.name for wo in historical_wos]\n    \n    # Get historical items\n    historical_items = frappe.get_all(\n        \"Work Order Item\",\n        filters={\"parent\": [\"in\", wo_names], \"parenttype\": \"Work Order\"},\n        fields=[\"parent\", \"item_code\", \"item_name\"],\n        ignore_permissions=True\n    )\n    \n    validation_errors = []\n    required_items = data.get(\"chemicals\") or []\n    \n    for rule in parsed_rules:\n        chemical = rule[\"chemical\"]\n        max_sprays = rule[\"max_sprays\"]\n        break_days = rule[\"break_days\"]\n        rule_lookback = frappe.utils.add_days(current_date, -break_days)\n        \n        # Get historical WOs for this chemical\n        historical_wo_map = {}\n        for record in historical_items:\n            wo_date = wo_dates.get(record.parent)\n            if wo_date and wo_date >= rule_lookback and record.item_name == chemical:\n                item_code = record.item_code\n                historical_wo_map[item_code] = historical_wo_map.get(item_code, set()).union({record.parent})\n        \n        # Check current items\n        for item in required_items:\n            if item.get(\"chemical\") != chemical:\n                continue\n            \n            item_name = item.get(\"chemical\")\n            item_data = item_rotation_map.get(item_name, {})\n            \n            # Check type matches\n            if not item_data.get('type', '').upper().startswith(code_type.upper()):\n                continue\n            \n            # Check codes match\n            if allowed_codes:\n                item_codes = item_data.get(code_type.upper(), set())\n                if not item_codes.intersection(allowed_codes):\n                    continue\n            \n            # Get past applications\n            history_wos = historical_wo_map.get(item_name, set())\n            if history_wos:\n                past_orders = frappe.get_all(\n                    \"Work Order\",\n                    filters={\"name\": [\"in\", list(history_wos)]},\n                    fields=[\"name\", \"custom_scheduled_application_time\"],\n                    order_by=\"custom_scheduled_application_time desc\",\n                    limit=max_sprays + 1,\n                    ignore_permissions=True\n                )\n            else:\n                past_orders = []\n            \n            spray_count = len(past_orders)\n            \n            # Check violations\n            error_parts = []\n            \n            if spray_count >= max_sprays:\n                action = \"will exceed\" if spray_count == max_sprays else \"has already exceeded\"\n                error_parts.append(f\"Max Sprays limit of {max_sprays} {action} (found {spray_count} applications)\")\n            \n            if spray_count > 0 and break_days > 0:\n                recent_date = frappe.utils.getdate(past_orders[0].custom_scheduled_application_time)\n                allowed_date = frappe.utils.add_days(recent_date, break_days)\n                \n                if current_date < allowed_date:\n                    days_left = (allowed_date - current_date).days\n                    if error_parts:\n                        error_parts.append(\"and\")\n                    error_parts.append(f\"a break of {break_days} days is required ({days_left} day(s) remaining)\")\n            \n            if error_parts:\n                validation_errors.append(f\"{item_name} failed because \" + \" \".join(error_parts) + \".\")\n    \n    return validation_errors\n\n\n# =================================================================================\n# --- MAIN EXECUTION ---\n# =================================================================================\nraw_json_string = frappe.form_dict.get(\"raw_data\")\n\nif not raw_json_string:\n    frappe.throw(\"Raw Work Order data is missing from the request.\")\n\ntry:\n    raw_data = json.loads(raw_json_string)\n    if not isinstance(raw_data, dict):\n        frappe.throw(\"Invalid format for Raw Work Order data. Expected a dictionary.\")\nexcept Exception as e:\n    frappe.log_error(f\"Failed to parse Raw Work Order data: {e}\", \"FRAC Validation\")\n    frappe.throw(\"CRITICAL ERROR: Failed to process application data. Invalid JSON format.\")\n\n# Extract data\nrequired_items = raw_data.get(\"chemicals\") or []\ncurrent_targets = {t.strip() for t in raw_data.get(\"custom_targets\", []) if t.strip()}\ncurrent_item_names = {item.get(\"chemical\") for item in required_items if item and item.get(\"chemical\")}\n\n# Get item rotation codes\nitem_rotation_map = get_item_rotation_codes(current_item_names, \"Main Validation\")\n\n# Run validations\nvalidation_results = {}\n\n# 1. Known Resistance\nerrors = validate_known_resistance_router(raw_data, item_rotation_map, current_targets)\nif errors:\n    validation_results[\"Targets With Known Resistance\"] = errors\n\n# 2. Alternate MoA\nfrac_errors = validate_alternate_moa_rotation(raw_data, item_rotation_map, \"frac\")\nirac_errors = validate_alternate_moa_rotation(raw_data, item_rotation_map, \"irac\")\nif frac_errors or irac_errors:\n    validation_results[\"Alternate MoA\"] = frac_errors + irac_errors\n\n# 3. Max Sprays\nfrac_errors = validate_max_sprays(raw_data, item_rotation_map, \"frac\")\nirac_errors = validate_max_sprays(raw_data, item_rotation_map, \"irac\")\nif frac_errors or irac_errors:\n    validation_results[\"Max Number Of Sprays\"] = frac_errors + irac_errors\n\n# Format and return results\nif validation_results:\n    output = [\"<h4>FRAC/IRAC Validation Failed:</h4><ul>\"]\n\n    for guideline_name, errors in validation_results.items():\n        # Default message\n        error_msg = f\"Validation failed for '{guideline_name}'.\"\n        doc_type = \"IRAC Guideline\" if any('IRAC' in e for e in errors) else \"FRAC Guideline\"\n\n        try:\n            guideline_doc = frappe.get_doc(doc_type, guideline_name)\n            error_msg = guideline_doc.error_message or error_msg\n        except frappe.DoesNotExistError:\n            pass\n\n        output.append(f\"<li><strong>{error_msg}</strong><ul>\")\n        for error in errors:\n            if not error.startswith(\"DEBUG:\"):\n                output.append(f\"<li>{frappe.utils.escape_html(error)}</li>\")\n        output.append(\"</ul></li>\")\n\n    output.append(\"</ul>\")\n\n    frappe.response[\"message\"] = {\n        \"status\": \"validation_failed\",\n        \"html\": \"\\n\".join(output),\n        \"message\": \"FRAC/IRAC validation failed.\"\n    }\n\nelse:\n    frappe.response[\"message\"] = {\n        \"status\": \"success\",\n        \"message\": \"Validation passed.\"\n    }\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Validate",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.230913",
  "module": "Upande Scp",
  "name": "Store Updated WO Required Qty",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Work Order",
  "script": "for row in doc.required_items:\n    row.custom_updated_required_qty = row.required_qty",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-11 18:17:30.199178",
  "module": "Upande Scp",
  "name": "Restore Updated WO Required Qty",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Work Order",
  "script": "for row in doc.required_items:\n    if row.get('custom_updated_required_qty'):\n        row.required_qty = row.custom_updated_required_qty",
  "script_type": "DocType Event"
 }
]