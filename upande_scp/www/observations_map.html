{% extends "upande_scp/www/base.html" %}

{% block head %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    :root {
        --bg: #ffffff;
        --text: #1f2937;
        --border: #d1d5db;
        --sidebar-bg: #f3f4f6;
        --sidebar-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        --accent: #4b5563;
        --accent-hover: #374151;
        --hover: #e5e7eb;
        --success: #059669;
        --warning: #f59e0b;
        --danger: #ef4444;
    }

    [data-theme="dark"] {
        --bg: #0f172a;
        --text: #f1f5f9;
        --border: #334155;
        --sidebar-bg: rgba(15, 23, 42, 0.98);
        --sidebar-shadow: 0 -4px 24px rgba(0, 0, 0, 0.5);
        --hover: #1e293b;
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    html,
    body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: var(--bg);
        color: var(--text);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }

    #map-page {
        height: 100vh;
        width: 100%;
        display: flex;
        position: relative;
    }

    #map-container {
        flex: 1;
        position: relative;
        z-index: 1;
    }

    #map {
        height: 100%;
        width: 100%;
    }

    /* Enhanced Sidebar */
    #sidebar {
        position: absolute;
        right: 0;
        top: 0;
        width: 380px;
        height: 100%;
        background: var(--sidebar-bg);
        backdrop-filter: blur(16px);
        border-left: 1px solid var(--border);
        box-shadow: var(--sidebar-shadow);
        z-index: 1000;
        display: flex;
        flex-direction: column;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
    }

    #sidebar.collapsed {
        transform: translateX(100%);
    }

    /* Toggle Button */
    .sidebar-toggle {
        position: absolute;
        left: -48px;
        top: 50%;
        transform: translateY(-50%);
        width: 48px;
        height: 96px;
        background: var(--sidebar-bg);
        border: 1px solid var(--border);
        border-right: none;
        border-radius: 8px 0 0 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: -2px 0 8px rgba(0, 0, 0, 0.05);
    }

    .sidebar-toggle:hover {
        background: var(--hover);
        left: -52px;
    }

    .sidebar-toggle svg {
        width: 24px;
        height: 24px;
        color: var(--text);
        opacity: 0.7;
        transition: transform 0.3s ease;
    }

    #sidebar.collapsed .sidebar-toggle svg {
        transform: rotate(180deg);
    }

    .sidebar-title {
        font-size: 1.25rem;
        font-weight: 700;
        margin-bottom: 0.25rem;
        letter-spacing: -0.025em;
    }

    .sidebar-subtitle {
        font-size: 0.875rem;
        opacity: 0.9;
    }

    /* Sidebar Content */
    .sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .sidebar-content::-webkit-scrollbar {
        width: 6px;
    }

    .sidebar-content::-webkit-scrollbar-track {
        background: transparent;
    }

    .sidebar-content::-webkit-scrollbar-thumb {
        background: var(--border);
        border-radius: 3px;
    }

    .sidebar-content::-webkit-scrollbar-thumb:hover {
        background: var(--accent);
    }

    /* Section */
    .section {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .section-label {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text);
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .section-label svg {
        width: 16px;
        height: 16px;
        opacity: 0.7;
    }

    .date-input {
        padding: 0.75rem 1rem;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: var(--bg);
        color: var(--text);
        font-size: 0.9375rem;
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .date-input:hover {
        border-color: var(--accent);
    }

    .date-input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Category Tabs */
    .category-tabs {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.5rem;
        background: var(--bg);
        border-radius: 8px;
    }

    .tab-btn {
        flex: 1;
        min-width: calc(50% - 0.25rem);
        padding: 0.625rem 0.875rem;
        border: 1.5px solid var(--border);
        background: var(--sidebar-bg);
        color: var(--text);
        font-size: 0.8125rem;
        font-weight: 600;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        position: relative;
        overflow: hidden;
    }

    .tab-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--accent);
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .tab-btn span {
        position: relative;
        z-index: 1;
    }

    .tab-btn:hover:not(.active) {
        border-color: var(--accent);
        transform: translateY(-1px);
    }

    .tab-btn.active {
        background: var(--accent);
        border-color: var(--accent);
        color: white;
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    /* Observation Items */
    .items-container {
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
    }

    .type-section {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .type-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem 0;
    }

    .type-title {
        font-size: 0.9375rem;
        font-weight: 700;
        color: var(--accent);
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .selection-controls {
        display: flex;
        gap: 0.375rem;
    }

    .select-btn {
        padding: 0.375rem 0.75rem;
        border: 1px solid var(--border);
        background: var(--bg);
        color: var(--text);
        font-size: 0.75rem;
        font-weight: 500;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .select-btn:hover {
        background: var(--accent);
        border-color: var(--accent);
        color: white;
        transform: scale(1.05);
    }

    .select-btn:active {
        transform: scale(0.98);
    }

    /* Legend Items */
    .legend-items {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.875rem;
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: var(--bg);
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .legend-item:hover {
        background: var(--hover);
        border-color: var(--accent);
        transform: translateX(-2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .legend-item input[type="checkbox"] {
        width: 18px;
        height: 18px;
        margin: 0;
        cursor: pointer;
        accent-color: var(--accent);
    }

    .color-swatch {
        width: 20px;
        height: 20px;
        border-radius: 6px;
        flex-shrink: 0;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .legend-label {
        flex: 1;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text);
    }

    /* Empty State */
    .empty-state {
        text-align: center;
        padding: 2rem 1rem;
        color: #94a3b8;
    }

    .empty-state svg {
        width: 48px;
        height: 48px;
        margin: 0 auto 1rem;
        opacity: 0.5;
    }

    .empty-state p {
        font-size: 0.875rem;
        margin-top: 0.5rem;
    }

    /* Loader */
    #map-loader {
        position: absolute;
        inset: 0;
        background: var(--bg);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        gap: 1.5rem;
    }

    .spinner {
        width: 48px;
        height: 48px;
        border: 3px solid var(--border);
        border-top: 3px solid var(--accent);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    .loader-text {
        font-size: 0.9375rem;
        color: var(--text);
        font-weight: 500;
    }

    /* Map Style Selector */
    .style-selector {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .style-option {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.625rem 0.875rem;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid transparent;
    }

    .style-option:hover {
        background: var(--hover);
        border-color: var(--border);
    }

    .style-option input[type="radio"] {
        width: 16px;
        height: 16px;
        margin: 0;
        accent-color: var(--accent);
    }

    .style-option label {
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        flex: 1;
    }

    /* Responsive */
    @media (max-width: 768px) {
        #sidebar {
            width: 100%;
            max-width: 380px;
        }

        .tab-btn {
            min-width: 100%;
        }
    }

    /* Leaflet Customization */
    .leaflet-control-layers {
        border: none !important;
        box-shadow: 0 2px 16px rgba(0, 0, 0, 0.1) !important;
        border-radius: 8px !important;
        overflow: hidden;
    }

    .line-id-label {
        background: none !important;
        border: none !important;
    }

    .leaflet-control-zoom {
        border: none !important;
        box-shadow: 0 2px 16px rgba(0, 0, 0, 0.1) !important;
    }

    .leaflet-control-zoom a {
        border: none !important;
        border-bottom: 1px solid var(--border) !important;
        color: var(--text) !important;
        background: var(--sidebar-bg) !important;
    }

    .leaflet-control-zoom a:hover {
        background: var(--hover) !important;
    }
</style>
{% endblock %}

{% block page_content %}
<div id="map-page">
    <div id="map-container">
        <div id="map-loader">
            <div class="spinner"></div>
            <p class="loader-text">Loading observation data...</p>
        </div>
        <div id="map"></div>
    </div>

    <div id="sidebar">
        <div class="sidebar-toggle" id="toggle-sidebar">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
        </div>

       
        <div class="sidebar-content">
            <div class="section">
                <label class="section-label">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    Observation Date
                </label>
                <input type="date" id="scout-date-picker" class="date-input" />
            </div>

            <div class="section">
                <label class="section-label">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
                    </svg>
                    Select Categories
                </label>
                <div class="category-tabs" id="category-tabs"></div>
            </div>

            <div class="section">
                <label class="section-label">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                    </svg>
                    Observations
                </label>
                <div class="items-container" id="observations-list"></div>
            </div>

            <div class="section" id="map-style-section" style="display:none;">
                <label class="section-label">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                    </svg>
                    Map Style
                </label>
                <div class="style-selector">
                    <div class="style-option">
                        <input type="radio" name="flavor" value="light" id="style-light" checked>
                        <label for="style-light">Light</label>
                    </div>
                    <div class="style-option">
                        <input type="radio" name="flavor" value="dark" id="style-dark">
                        <label for="style-dark">Dark</label>
                    </div>
                    <div class="style-option">
                        <input type="radio" name="flavor" value="white" id="style-white">
                        <label for="style-white">White</label>
                    </div>
                    <div class="style-option">
                        <input type="radio" name="flavor" value="grayscale" id="style-gray">
                        <label for="style-gray">Grayscale</label>
                    </div>
                    <div class="style-option">
                        <input type="radio" name="flavor" value="black" id="style-black">
                        <label for="style-black">Black</label>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-providers/1.13.0/leaflet-providers.min.js"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://unpkg.com/protomaps-leaflet@5.0.0/dist/protomaps-leaflet.js"></script>
<script src="/assets/frappe/js/frappe-web.min.js"></script>

<script>
    window.onload = function () {
        /* ---------------- 1. Globals ---------------- */
        window.map = null;
        let mapInitialized = false;
        window.zoneLayer = null;
        window.lineIdLabels = null;
        window.overlayLayers = {};
        let protomapsLayer = null;
        let layersControl = null;
        let darkFlavor = false;

        window.observationData = {};
        window.selectedTypes = new Set();
        window.selectedItems = {};

        const sidebar = document.getElementById('sidebar');
        const toggleBtn = document.getElementById('toggle-sidebar');
        const categoryTabs = document.getElementById('category-tabs');
        const observationsList = document.getElementById('observations-list');
        const mapStyleSection = document.getElementById('map-style-section');

        toggleBtn.addEventListener('click', () => {
            sidebar.classList.toggle('collapsed');
        });

        const showLoader = () => document.getElementById('map-loader').style.display = 'flex';
        const hideLoader = () => document.getElementById('map-loader').style.display = 'none';

        /* ---------------- Blend Colors ---------------- */
        const blendColors = colors => {
            if (!colors.length) return "#999";
            let r = 0, g = 0, b = 0;
            colors.forEach(c => {
                const h = c.replace("#", "");
                r += parseInt(h.substr(0, 2), 16);
                g += parseInt(h.substr(2, 2), 16);
                b += parseInt(h.substr(4, 2), 16);
            });
            return `rgb(${Math.round(r / colors.length)},${Math.round(g / colors.length)},${Math.round(b / colors.length)})`;
        };

        /* ---------------- Render Overlays ---------------- */
        const renderOverlayForType = (type, scoutingData, zonesGeojson) => {
            if (window.overlayLayers[type]) window.map.removeLayer(window.overlayLayers[type]);
            const lg = L.layerGroup();
            const filtered = new Set(window.selectedItems[type] || []);

            // If no items are selected for this type, don't render anything
            if (filtered.size === 0) {
                window.overlayLayers[type] = lg;
                return;
            }

            // Offset calculation removed here

            (zonesGeojson || []).forEach(zone => {
                let gj;
                try { gj = JSON.parse(zone.raw_geojson); } catch { return; }
                const coords = gj.features?.[0]?.geometry?.coordinates?.map(c => [c[1], c[0]]) || [];
                if (!coords.length) return;

                const line = turf.lineString(coords.map(c => [c[1], c[0]]));
                const entries = (scoutingData || []).filter(e => e.zone === zone.name);
                if (!entries.length) return;

                const totalLen = turf.length(line, { units: 'meters' });
                const segLen = totalLen / entries.length;

                entries.forEach((entry, i) => {
                    const obs = entry[type] || [];
                    
                    const relevant = obs.filter(o => {
                        const name = o.name;
                        return filtered.has(name);
                    });
                    
                    if (!relevant.length) return;

                    const colours = relevant.map(o => o.color || '#999');
                    const col = blendColors(colours);

                    const start = turf.along(line, i * segLen, { units: 'meters' });
                    const end = turf.along(line, (i + 1) * segLen, { units: 'meters' });
                    
                    // Offset application removed - using original coordinates
                    const seg = [
                        [start.geometry.coordinates[1], start.geometry.coordinates[0]],
                        [end.geometry.coordinates[1], end.geometry.coordinates[0]]
                    ];

                    const tip = relevant.map(o => `${o.name}: ${o.count || 1}`).join('<br>');
                    const meta = window.observationData.observation_metadata?.[type] || {};
                    const typeLabel = meta.label || type.replace(/_/g, ' ');
                    
                    const poly = L.polyline(seg, { 
                        color: col, 
                        weight: 4, 
                        opacity: 0.85,
                        className: `overlay-${type}`
                    });
                    poly.bindTooltip(`<div style="font-size:0.8125rem;line-height:1.4;"><strong style="display:block;margin-bottom:0.25rem;">${zone.name}</strong><em style="font-size:0.75rem;opacity:0.8;">${typeLabel}</em><br>${tip}</div>`, { sticky: true });
                    poly.addTo(lg);
                });
            });

            lg.addTo(window.map);
            window.overlayLayers[type] = lg;
        };

        const renderAllOverlays = () => {
            Object.keys(window.overlayLayers).forEach(t => {
                if (window.map.hasLayer(window.overlayLayers[t])) {
                    window.map.removeLayer(window.overlayLayers[t]);
                }
            });
            window.selectedTypes.forEach(t => renderOverlayForType(t, window.lastScoutingData, window.lastZonesGeojson));
        };

        /* ---------------- Render Zones ---------------- */
        const renderZones = data => {
            if (window.zoneLayer) window.map.removeLayer(window.zoneLayer);
            if (window.lineIdLabels) {
                window.map.removeLayer(window.lineIdLabels);
                window.lineIdLabels = null;
            }

            const lines = {};
            (data.all_zones_geojson || []).forEach(zone => {
                try {
                    const gj = JSON.parse(zone.raw_geojson);
                    const gh = zone.name.split(' - ')[0];
                    if (gj.features) {
                        gj.features.forEach(f => {
                            const lineId = f.properties.line_id;
                            const key = `${gh}_line_${lineId}`;
                            f.properties.zone_name = zone.name;
                            if (!lines[key]) lines[key] = [];
                            lines[key].push(f);
                        });
                    }
                } catch (e) { console.error('Bad GeoJSON', zone.name, e); }
            });

            window.lineIdLabels = L.layerGroup().addTo(window.map);
            Object.values(lines).forEach(arr => {
                if (!arr.length) return;
                arr.sort((a, b) => a.properties.zone_id - b.properties.zone_id);
                const coords = arr.flatMap(f => f.geometry.coordinates);
                const lineId = arr[0].properties.line_id;
                const odd = parseInt(lineId) % 2 !== 0;
                const pt = odd ? coords[0] : coords[coords.length - 1];
                const lbl = L.marker([pt[1], pt[0]], {
                    icon: L.divIcon({
                        className: 'line-id-label',
                        html: `<div style="font-size:4px;font-weight:200;color:${darkFlavor ? '#fff' : '#000'};transform:rotate(45deg);">${lineId}</div>`,
                        iconSize: [20, 10], iconAnchor: [0, 0]
                    })
                });
                window.lineIdLabels.addLayer(lbl);
            });

            const fc = { type: "FeatureCollection", features: Object.values(lines).flat() };
            window.zoneLayer = L.geoJSON(fc, {
                style: { color: darkFlavor ? '#fff' : '#1e293b', weight: 0.7, opacity: 0.6 },
                onEachFeature: (f, l) => {
                    if (f.properties?.zone_id) {
                        const zn = f.properties.zone_name || '';
                        const parts = zn.split(' - ');
                        let html = zn;
                        if (parts.length >= 4) {
                            const [gh, kr, bed, zone] = parts;
                            html = `<div style="font-size:0.75rem;line-height:1.5;"><strong style="display:block;margin-bottom:0.25rem;">${gh}</strong><div style="opacity:0.9;">${kr}</div><div style="opacity:0.9;">${bed}</div><div style="opacity:0.9;">${zone}</div></div>`;
                        }
                        l.bindTooltip(html, { permanent: false, direction: 'top' });
                    }
                }
            });

            window.map.on('zoomend', () => {
                const z = window.map.getZoom();
                if (z >= 15) { if (!window.map.hasLayer(window.zoneLayer)) window.zoneLayer.addTo(window.map); }
                else { if (window.map.hasLayer(window.zoneLayer)) window.map.removeLayer(window.zoneLayer); }
                if (z >= 18) { if (!window.map.hasLayer(window.lineIdLabels)) window.lineIdLabels.addTo(window.map); }
                else { if (window.map.hasLayer(window.lineIdLabels)) window.map.removeLayer(window.lineIdLabels); }
            });

            if (window.map.getZoom() >= 15) window.zoneLayer.addTo(window.map);
            if (window.map.getZoom() >= 18) window.lineIdLabels.addTo(window.map);
        };

        /* ---------------- Data Fetch ---------------- */
        const fetchAllData = date => {
            showLoader();
            fetch('/api/method/upande_scp.serverscripts.get_scouting_observations.getScoutingObservations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Frappe-CSRF-Token': "{{csrf_token}}"
                },
                body: JSON.stringify({ date })
            })
                .then(r => r.ok ? r.json() : Promise.reject(r))
                .then(r => {
                    const data = r.message;
                    window.observationData = data;
                    window.lastZoneData = data;
                    window.lastScoutingData = data.scouting_entries;
                    window.lastZonesGeojson = data.all_zones_geojson;

                    // Initialize selection state
                    const types = data.active_observation_types || [];
                                        
                    // Extract actual observation names from scouting entries if all_observation_names is empty
                    types.forEach(t => {
                        if (!window.selectedItems[t]) {
                            // First try to use the provided all_observation_names
                            let items = (data.all_observation_names?.[t] || []).map(i => i.name);
                            
                            
                            // If empty, extract from actual scouting entries
                            if (items.length === 0 && data.scouting_entries) {
                                const uniqueNames = new Set();
                                data.scouting_entries.forEach(entry => {
                                    const observations = entry[t] || [];
                                    observations.forEach(obs => {
                                        if (obs.name) uniqueNames.add(obs.name);
                                    });
                                });
                                items = Array.from(uniqueNames);
                                                                
                                // Also populate all_observation_names for later use
                                if (!data.all_observation_names[t]) {
                                    data.all_observation_names[t] = [];
                                }
                                data.all_observation_names[t] = items.map(name => ({
                                    name: name,
                                    color: '#999' // Default color, will be overridden by actual data
                                }));
                            }
                            
                            window.selectedItems[t] = items;
                        }
                    });
                    
                    // Select ALL types by default (not just the first one)
                    if (window.selectedTypes.size === 0) {
                        types.forEach(type => {
                            const hasData = (data.all_observation_names[type] && data.all_observation_names[type].length > 0) ||
                                            (window.selectedItems[type] && window.selectedItems[type].length > 0);
                            if (hasData) {
                                window.selectedTypes.add(type);
                            }
                        });
                    }

                    renderZones(data);
                    renderCategoryTabs();
                    renderObservationsList();
                    renderAllOverlays();
                })
                .catch(err => {
                    frappe.msgprint('Failed to load scouting data');
                    observationsList.innerHTML = `
                        <div class="empty-state">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                            </svg>
                            <p><strong>Failed to load data</strong></p>
                            <p>Please try again or select a different date</p>
                        </div>
                    `;
                })
                .finally(hideLoader);
        };

        /* ---------------- Init Map ---------------- */
        const initializeMap = () => {
            if (mapInitialized) return;

            window.map = L.map('map', {
                zoomSnap: 0.1,
                zoomDelta: 0.1,
                maxZoom: 22.4,
                zoomControl: true
            });
            mapInitialized = true;
            renderBaseLayers();
            window.map.setView([0.069507, 35.755801], 18);

            const datePicker = document.getElementById('scout-date-picker');
            const today = new Date().toISOString().slice(0, 10);
            datePicker.value = today;
            fetchAllData(today);
            datePicker.addEventListener('change', e => fetchAllData(e.target.value));
        };

        const renderBaseLayers = () => {
            const googleSat = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { maxZoom: 25 });
            const osmStreet = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 25 });
            const osmSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 25 });

            const pmtilesUrl = 'https://res.cloudinary.com/dorft5vxy/raw/upload/v1757410567/eldama-ravine_gdtrsv.pmtiles';
            protomapsLayer = protomapsL.leafletLayer({
                url: pmtilesUrl,
                flavor: "light",
                attribution: "© Protomaps © OpenStreetMap"
            });
            protomapsLayer.addTo(window.map);

            const baseMaps = {
                "Satellite View": googleSat,
                "Street Map": osmStreet,
                "OSM Satellite": osmSat,
                "Protomaps Layer": protomapsLayer
            };

            layersControl = L.control.layers(baseMaps, {}, {
                collapsed: false,
                position: 'topleft'
            }).addTo(window.map);

            document.querySelectorAll('input[name="flavor"]').forEach(radio => {
                radio.addEventListener('change', e => {
                    const newFlavor = e.target.value;
                    darkFlavor = ['dark', 'black'].includes(newFlavor);
                    document.documentElement.setAttribute('data-theme', darkFlavor ? 'dark' : 'light');
                    if (window.lastZoneData) renderZones(window.lastZoneData);
                    if (window.map.hasLayer(protomapsLayer)) {
                        window.map.removeLayer(protomapsLayer);
                        layersControl.removeLayer(protomapsLayer);
                    }
                    protomapsLayer = protomapsL.leafletLayer({
                        url: pmtilesUrl,
                        flavor: newFlavor,
                        attribution: "© Protomaps © OpenStreetMap"
                    });
                    protomapsLayer.addTo(window.map);
                    layersControl.addBaseLayer(protomapsLayer, "Protomaps Layer");
                });
            });

            window.map.on('baselayerchange', e => {
                mapStyleSection.style.display = e.name === "Protomaps Layer" ? 'flex' : 'none';
            });
        };

        /* ---------------- Category Tabs ---------------- */
        const renderCategoryTabs = () => {
            const types = window.observationData.active_observation_types || [];
            categoryTabs.innerHTML = '';

            if (!types.length) {
                categoryTabs.innerHTML = '<p style="font-size:.75rem;color:#999;text-align:center;padding:1rem;">No observation types available</p>';
                return;
            }

            types.forEach(type => {
                const meta = window.observationData.observation_metadata?.[type] || {};
                const label = meta.label || type.replace(/_scouting_entry$/, '').replace(/_/g, ' ');

                const btn = document.createElement('button');
                btn.className = `tab-btn ${window.selectedTypes.has(type) ? 'active' : ''}`;
                btn.innerHTML = `<span>${label}</span>`;
                btn.addEventListener('click', () => {
                    if (window.selectedTypes.has(type)) {
                        window.selectedTypes.delete(type);
                    } else {
                        window.selectedTypes.add(type);
                    }
                    renderCategoryTabs();
                    renderObservationsList();
                    renderAllOverlays();
                });
                categoryTabs.appendChild(btn);
            });
        };

        /* ---------------- Observations List ---------------- */
        const renderObservationsList = () => {
            observationsList.innerHTML = '';

            const activeTypes = Array.from(window.selectedTypes);
            if (!activeTypes.length) {
                observationsList.innerHTML = `
                    <div class="empty-state">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"/>
                        </svg>
                        <p><strong>No categories selected</strong></p>
                        <p>Select one or more categories above</p>
                    </div>
                `;
                return;
            }

            activeTypes.forEach(type => {
                const meta = window.observationData.observation_metadata?.[type] || {};
                const items = window.observationData.all_observation_names?.[type] || [];

                // Extract colors from actual scouting data for this type
                const colorMap = new Map();
                if (window.lastScoutingData) {
                    window.lastScoutingData.forEach(entry => {
                        const observations = entry[type] || [];
                        observations.forEach(obs => {
                            if (obs.name && obs.color && !colorMap.has(obs.name)) {
                                colorMap.set(obs.name, obs.color);
                            }
                        });
                    });
                }

                const section = document.createElement('div');
                section.className = 'type-section';

                const header = document.createElement('div');
                header.className = 'type-header';
                header.innerHTML = `
                    <div class="type-title">${meta.label || type.replace(/_/g, ' ')}</div>
                    <div class="selection-controls">
                        <button class="select-btn" data-type="${type}" data-action="all">All</button>
                        <button class="select-btn" data-type="${type}" data-action="none">None</button>
                    </div>
                `;
                section.appendChild(header);

                if (!items.length) {
                    section.innerHTML += '<p style="font-size:0.8125rem;color:#999;padding:0.5rem;text-align:center;">No observations recorded</p>';
                } else {
                    const itemsDiv = document.createElement('div');
                    itemsDiv.className = 'legend-items';

                    items.forEach(item => {
                        const checked = window.selectedItems[type]?.includes(item.name);
                        // Use color from actual data if available, otherwise use default
                        const color = colorMap.get(item.name) || item.color || '#999';
                        const itemDiv = document.createElement('label');
                        itemDiv.className = 'legend-item';
                        itemDiv.innerHTML = `
                            <input type="checkbox" data-type="${type}" value="${item.name}" ${checked ? 'checked' : ''}>
                            <span class="color-swatch" style="background-color:${color}"></span>
                            <span class="legend-label">${item.name}</span>
                        `;
                        itemsDiv.appendChild(itemDiv);
                    });
                    section.appendChild(itemsDiv);
                }

                observationsList.appendChild(section);
            });

            setupObservationsListeners();
        };

        const setupObservationsListeners = () => {
            document.querySelectorAll('.legend-item input[type="checkbox"]').forEach(cb => {
                cb.addEventListener('change', e => {
                    const type = e.target.dataset.type;
                    const name = e.target.value;
                    if (!window.selectedItems[type]) window.selectedItems[type] = [];

                    if (e.target.checked) {
                        if (!window.selectedItems[type].includes(name)) {
                            window.selectedItems[type].push(name);
                        }
                    } else {
                        window.selectedItems[type] = window.selectedItems[type].filter(n => n !== name);
                    }
                    
                    renderAllOverlays();
                });
            });

            document.querySelectorAll('.select-btn').forEach(btn => {
                btn.addEventListener('click', e => {
                    const type = e.target.dataset.type;
                    const action = e.target.dataset.action;
                    const items = window.observationData.all_observation_names[type];

                    if (action === 'all') {
                        window.selectedItems[type] = items.map(i => i.name);
                    } else {
                        window.selectedItems[type] = [];
                    }
                    
                    renderObservationsList();
                    renderAllOverlays();
                });
            });
        };

        /* ---------------- Initialize ---------------- */
        initializeMap();
    };
</script>
{% endblock %}