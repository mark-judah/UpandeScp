{% extends "upande_scp/www/map_base.html" %}

{% block head %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
    :root {
        --bg: #ffffff;
        --text: #1f2937;
        --border: #d1d5db;
        --sidebar-bg: #f3f4f6;
        --sidebar-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        --accent: #4b5563;
        --accent-hover: #374151;
        --hover: #e5e7eb;
        --success: #059669;
        --warning: #f59e0b;
        --danger: #ef4444;
    }

    [data-theme="dark"] {
        --bg: #0f172a;
        --text: #f1f5f9;
        --border: #334155;
        --sidebar-bg: rgba(15, 23, 42, 0.98);
        --sidebar-shadow: 0 -4px 24px rgba(0, 0, 0, 0.5);
        --hover: #1e293b;
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    html,
    body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: var(--bg);
        color: var(--text);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }

    #map-page {
        height: 100vh;
        width: 100%;
        display: flex;
        position: relative;
    }

    #map-container {
        flex: 1;
        position: relative;
        z-index: 1;
    }

    #map {
        height: 100%;
        width: 100%;
    }

    /* Enhanced Sidebar */
    #sidebar {
        position: absolute;
        right: 0;
        top: 0;
        width: 380px;
        height: 100%;
        background: var(--sidebar-bg);
        backdrop-filter: blur(16px);
        border-left: 1px solid var(--border);
        box-shadow: var(--sidebar-shadow);
        z-index: 1000;
        display: flex;
        flex-direction: column;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
    }

    #sidebar.collapsed {
        transform: translateX(100%);
    }

    /* Toggle Button */
    .sidebar-toggle {
        position: absolute;
        left: -48px;
        top: 50%;
        transform: translateY(-50%);
        width: 48px;
        height: 96px;
        background: var(--sidebar-bg);
        border: 1px solid var(--border);
        border-right: none;
        border-radius: 8px 0 0 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: -2px 0 8px rgba(0, 0, 0, 0.05);
    }

    .sidebar-toggle:hover {
        background: var(--hover);
        left: -52px;
    }

    .sidebar-toggle svg {
        width: 24px;
        height: 24px;
        color: var(--text);
        opacity: 0.7;
        transition: transform 0.3s ease;
    }

    #sidebar.collapsed .sidebar-toggle svg {
        transform: rotate(180deg);
    }

    /* Sidebar Content */
    .sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .sidebar-content::-webkit-scrollbar {
        width: 6px;
    }

    .sidebar-content::-webkit-scrollbar-track {
        background: transparent;
    }

    .sidebar-content::-webkit-scrollbar-thumb {
        background: var(--border);
        border-radius: 3px;
    }

    .sidebar-content::-webkit-scrollbar-thumb:hover {
        background: var(--accent);
    }

    /* Section */
    .section {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .section-label {
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text);
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .section-label svg {
        width: 16px;
        height: 16px;
        opacity: 0.7;
    }

    .date-input {
        padding: 0.75rem 1rem;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: var(--bg);
        color: var(--text);
        font-size: 0.9375rem;
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .date-input:hover {
        border-color: var(--accent);
    }

    .date-input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Legend Items */
    .legend-items {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.875rem;
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: var(--bg);
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .legend-item:hover {
        background: var(--hover);
        border-color: var(--accent);
        transform: translateX(-2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .legend-item input[type="checkbox"] {
        width: 18px;
        height: 18px;
        margin: 0;
        cursor: pointer;
        accent-color: var(--accent);
    }

    .color-swatch {
        width: 20px;
        height: 20px;
        border-radius: 6px;
        flex-shrink: 0;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .legend-label {
        flex: 1;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text);
    }

    /* Empty State */
    .empty-state {
        text-align: center;
        padding: 2rem 1rem;
        color: #94a3b8;
    }

    .empty-state svg {
        width: 48px;
        height: 48px;
        margin: 0 auto 1rem;
        opacity: 0.5;
    }

    .empty-state p {
        font-size: 0.875rem;
        margin-top: 0.5rem;
    }

    /* Map Style Selector */
    .style-selector {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .style-option {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.625rem 0.875rem;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid transparent;
    }

    .style-option:hover {
        background: var(--hover);
        border-color: var(--border);
    }

    .style-option input[type="radio"] {
        width: 16px;
        height: 16px;
        margin: 0;
        accent-color: var(--accent);
    }

    .style-option label {
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        flex: 1;
    }

    /* Loader */
    #map-loader {
        position: absolute;
        inset: 0;
        background: var(--bg);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        gap: 1.5rem;
    }

    .spinner {
        width: 48px;
        height: 48px;
        border: 3px solid var(--border);
        border-top: 3px solid var(--accent);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    .loader-text {
        font-size: 0.9375rem;
        color: var(--text);
        font-weight: 500;
    }

    /* Responsive */
    @media (max-width: 768px) {
        #sidebar {
            width: 100%;
            max-width: 380px;
        }
    }

    /* Leaflet Customization */
    .leaflet-control-layers {
        border: none !important;
        box-shadow: 0 2px 16px rgba(0, 0, 0, 0.1) !important;
        border-radius: 8px !important;
        overflow: hidden;
    }

    .line-id-label {
        background: none !important;
        border: none !important;
        font-family: sans-serif;
        pointer-events: none;
    }

    .leaflet-control-zoom {
        border: none !important;
        box-shadow: 0 2px 16px rgba(0, 0, 0, 0.1) !important;
    }

    .leaflet-control-zoom a {
        border: none !important;
        border-bottom: 1px solid var(--border) !important;
        color: var(--text) !important;
        background: var(--sidebar-bg) !important;
    }

    .leaflet-control-zoom a:hover {
        background: var(--hover) !important;
    }
</style>
{% endblock %}

{% block page_content %}
<div id="map-page">
    <div id="map-container">
        <div id="map-loader">
            <div class="spinner"></div>
            <p class="loader-text">Loading scouting data...</p>
        </div>
        <div id="map"></div>
    </div>

    <div id="sidebar">
        <div class="sidebar-toggle" id="toggle-sidebar">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
        </div>

        <div class="sidebar-content">
            <div class="section">
                <label class="section-label">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    Scouting Date
                </label>
                <input type="date" id="scout-date-picker" class="date-input" />
            </div>

            <div class="section">
                <label class="section-label">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                    </svg>
                    Scout Coverage
                </label>
                <div class="legend-items" id="scout-legend"></div>
            </div>

            <div class="section" id="map-style-section">
                <label class="section-label">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                    </svg>
                    Map Style
                </label>
                <div class="style-selector">
                    <div class="style-option">
                        <input type="radio" name="flavor" value="light" id="style-light" checked>
                        <label for="style-light">Light</label>
                    </div>
                    <div class="style-option">
                        <input type="radio" name="flavor" value="dark" id="style-dark">
                        <label for="style-dark">Dark</label>
                    </div>
                    <div class="style-option">
                        <input type="radio" name="flavor" value="white" id="style-white">
                        <label for="style-white">White</label>
                    </div>
                    <div class="style-option">
                        <input type="radio" name="flavor" value="grayscale" id="style-gray">
                        <label for="style-gray">Grayscale</label>
                    </div>
                    <div class="style-option">
                        <input type="radio" name="flavor" value="black" id="style-black">
                        <label for="style-black">Black</label>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-providers/1.13.0/leaflet-providers.min.js"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://unpkg.com/protomaps-leaflet@5.0.0/dist/protomaps-leaflet.js"></script>

<script>
    window.onload = function () {
        window.map = null;
        let mapInitialized = false;
        window.zoneLayer = null;
        window.lineIdLabels = null;
        window.scoutLayers = {};
        window.scoutedBedOverlay = null;
        let protomapsLayer = null;
        let layersControl = null;
        let darkFlavor = false;
        window.lastScoutingData = null;
        window.allLatLngs = [];
        let greenhouseOverlay = null;  // ← ADDED
        const palette = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#f43f5e', '#22c55e'];

        // Inject greenhouse GeoJSON from context (must be passed in get_context)
        window.greenhouses_geojson = {{ greenhouses_geojson | tojson | safe }};

        const sidebar = document.getElementById('sidebar');
        const toggleBtn = document.getElementById('toggle-sidebar');
        const mapStyleSection = document.getElementById('map-style-section');

        toggleBtn.addEventListener('click', () => {
            sidebar.classList.toggle('collapsed');
        });

        const showLoader = () => {
            const loader = document.getElementById('map-loader');
            if (loader) loader.style.display = 'flex';
        };

        const hideLoader = () => {
            const loader = document.getElementById('map-loader');
            if (loader) loader.style.display = 'none';
        };

        // ← ADDED: Exact same greenhouse overlay function
        const addGreenhouseOverlay = () => {
            if (greenhouseOverlay) {
                window.map.removeLayer(greenhouseOverlay);
            }

            if (!window.greenhouses_geojson?.length) {
                return;
            }

            const features = [];
            window.greenhouses_geojson.forEach(gh => {
                if (!gh.geojson?.features) return;
                gh.geojson.features.forEach(f => {
                    const clone = JSON.parse(JSON.stringify(f));

                    if (clone.geometry.type === 'Polygon') {
                        clone.geometry.coordinates = clone.geometry.coordinates.map(ring =>
                            ring.map(coord => {
                                const [lng, lat] = coord;
                                // No offset in this version → direct use
                                return [lng, lat];
                            })
                        );
                    }

                    clone.properties = clone.properties || {};
                    clone.properties.gh_name = gh.short_name || gh.name;
                    features.push(clone);
                });
            });

            if (!features.length) return;

            greenhouseOverlay = L.geoJSON(
                { type: "FeatureCollection", features },
                {
                    style: {
                        fillColor: "#5b684a",
                        fillOpacity: 0.64,
                        color: "transparent",
                        weight: 0,
                        interactive: false
                    },
                    onEachFeature: (f, layer) => {
                        const name = f.properties?.gh_name || "Greenhouse";
                        layer.bindTooltip(name, {
                            permanent: false,
                            direction: "center",
                            className: "gh-tooltip"
                        });
                    }
                }
            ).addTo(window.map);

            // Ensure zones stay on top
            if (window.zoneLayer) window.zoneLayer.bringToFront();
            if (window.lineIdLabels) window.lineIdLabels.bringToFront();
        };

        const generateScoutColors = (data) => {
            const scouts = (data.scouting_entries || []).map(i => i.scouts_name).filter(Boolean);
            const unique = new Set(scouts);
            const colors = {};
            let idx = 0;
            unique.forEach(name => {
                colors[name] = palette[idx % palette.length];
                idx++;
            });
            return colors;
        };

        const getGeoJsonCentroid = (geojson) => {
            try {
                const feature = geojson.features[0];
                if (!feature) return null;
                if (feature.geometry && feature.geometry.coordinates) {
                    const centroid = turf.centroid(feature);
                    const [lon, lat] = centroid.geometry.coordinates;
                    return [lat, lon];
                }
            } catch (e) {
                console.error("Error calculating centroid:", e);
            }
            return null;
        };

        function getEdgeMidpoint(coords) {
            try {
                const pts = coords.map(c => [c[1], c[0]]);
                let maxDist = 0, pair = [];
                for (let i = 0; i < pts.length; i++) {
                    const p1 = pts[i];
                    const p2 = pts[(i + 1) % pts.length];
                    const dist = turf.distance(turf.point([p1[1], p1[0]]), turf.point([p2[1], p2[0]]));
                    if (dist > maxDist) {
                        maxDist = dist;
                        pair = [p1, p2];
                    }
                }
                return [(pair[0][0] + pair[1][0]) / 2, (pair[0][1] + pair[1][1]) / 2];
            } catch {
                return coords[0] ? [coords[0][1], coords[0][0]] : null;
            }
        }

        function generateWalkPath(start, end) {
            if (!start || !end) return [];
            return [start, end];
        }

        const initializeMap = () => {
            if (mapInitialized) return;
            window.map = L.map('map', { zoomSnap: 0.1, zoomDelta: 0.1, maxZoom: 22.4, zoomControl: true });
            mapInitialized = true;
            renderBaseLayers();
            const lat = {{ lat | json }};
            const lon = {{ lon | json }};
            const zoom = {{ default_zoom | json }};
            map.setView([lat, lon], zoom);
            const picker = document.getElementById('scout-date-picker');
            const today = new Date().toISOString().slice(0, 10);
            picker.value = today;
            fetchAllData(today);
            picker.addEventListener('change', e => fetchAllData(e.target.value));
        };

        const renderBaseLayers = () => {
            const googleSat = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { maxZoom: 25 });
            const pmtilesUrl = 'https://res.cloudinary.com/dorft5vxy/raw/upload/v1757410567/eldama-ravine_gdtrsv.pmtiles';
            protomapsLayer = protomapsL.leafletLayer({
                url: pmtilesUrl,
                flavor: "light",
                attribution: "© Protomaps © OpenStreetMap"
            });
            googleSat.addTo(map);
            layersControl = L.control.layers({ "Satellite": googleSat, "Protomaps": protomapsLayer }, {}, { collapsed: false, position: 'topleft' }).addTo(map);

            document.querySelectorAll('input[name="flavor"]').forEach(radio => {
                radio.addEventListener('change', e => {
                    const newFlavor = e.target.value;
                    darkFlavor = ['dark', 'black'].includes(newFlavor);
                    document.documentElement.setAttribute('data-theme', darkFlavor ? 'dark' : 'light');
                    if (window.lastZoneData) renderZones(window.lastZoneData);
                    if (window.map.hasLayer(protomapsLayer)) {
                        window.map.removeLayer(protomapsLayer);
                        layersControl.removeLayer(protomapsLayer);
                    }
                    protomapsLayer = protomapsL.leafletLayer({
                        url: pmtilesUrl,
                        flavor: newFlavor,
                        attribution: "© Protomaps © OpenStreetMap"
                    });
                    protomapsLayer.addTo(window.map);
                    layersControl.addBaseLayer(protomapsLayer, "Protomaps");
                });
            });

            window.map.on('baselayerchange', e => {
                mapStyleSection.style.display = e.name === "Protomaps" ? 'flex' : 'none';
            });
        };

        const fetchAllData = (date) => {
            if (window.scoutedBedOverlay) map.removeLayer(window.scoutedBedOverlay);
            window.scoutLayers = {};
            document.getElementById('scout-legend').innerHTML = '';
            window.allLatLngs = [];

            showLoader();
            fetch('/api/method/upande_scp.serverscripts.get_scouting_analysis.getScoutingAnalysis', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Frappe-CSRF-Token': "{{csrf_token}}"
                },
                body: JSON.stringify({
                    date: date
                })
            }).then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            }).then(r => {
                const allData = r.message || r.data;
                if (allData) {
                    window.lastScoutingData = allData;
                    window.lastZoneData = allData;
                    allData.scouting_entries = (allData.scouting_entries || []).filter(e => e.scouts_name);
                    const scoutColors = generateScoutColors(allData);
                    window.scoutedBedOverlay = L.layerGroup().addTo(map);

                    renderZones(allData);
                    renderScoutFlowLines(allData.scouting_entries || [], allData.all_zones_geojson || [], scoutColors);
                    renderScoutedBeds(allData.scouting_entries || [], allData.all_zones_geojson || [], scoutColors);
                    renderScoutLegend(scoutColors);

                } else {
                    document.getElementById('scout-legend').innerHTML = '<div class="empty-state"><p>No Scout Data</p></div>';
                }
            }).catch(error => {
                console.error('Error fetching scouting data:', error);
                document.getElementById('scout-legend').innerHTML = `<div class="empty-state"><p>Error: ${error.message}</p></div>`;
            })
                .finally(() => {
                    hideLoader();
                });
        };

        function renderScoutedBeds(scoutingData, zonesGeojson, scoutColors) {
            const zoneScoutMap = {};
            scoutingData.forEach(entry => {
                if (!zoneScoutMap[entry.zone]) {
                    zoneScoutMap[entry.zone] = { scout: entry.scouts_name, count: 0, latestEntry: null };
                }
                zoneScoutMap[entry.zone].count++;
                if (!zoneScoutMap[entry.zone].latestEntry || entry.creation > zoneScoutMap[entry.zone].latestEntry) {
                    zoneScoutMap[entry.zone].latestEntry = entry.creation;
                }
                if (!window.scoutLayers[entry.scouts_name]) window.scoutLayers[entry.scouts_name] = L.layerGroup();
            });

            const zoneMap = new Map((zonesGeojson || []).map(z => [z.name, z]));
            Object.entries(zoneScoutMap).forEach(([zoneName, info]) => {
                const zone = zoneMap.get(zoneName);
                if (!zone) return;
                try {
                    const geo = JSON.parse(zone.raw_geojson);
                    const coords = geo.features[0].geometry.coordinates.map(c => [c[1], c[0]]);
                    const color = scoutColors[info.scout];

                    const line = L.polyline(coords, { color, weight: 0, opacity: 1, pane: 'overlayPane' });

                    line.bindTooltip(`<div style='font-size:0.8125rem;line-height:1.4;'><strong style='display:block;margin-bottom:0.25rem;'>${zone.name}</strong>${info.scout}<br>${info.count} entries</div>`);
                    window.scoutLayers[info.scout].addLayer(line);
                    window.allLatLngs.push(...coords);
                    if (!window.scoutedBedOverlay.hasLayer(window.scoutLayers[info.scout])) window.scoutedBedOverlay.addLayer(window.scoutLayers[info.scout]);
                } catch { }
            });
        }

        function renderScoutFlowLines(scoutingEntries, zonesGeojson, scoutColors) {
            const zoneMap = new Map((zonesGeojson || []).map(z => [z.name, z]));
            const movement = new Map();

            scoutingEntries.sort((a, b) => new Date(a.creation) - new Date(b.creation))
                .forEach(entry => {
                    const zone = zoneMap.get(entry.zone);
                    if (!zone) return;
                    try {
                        const geo = JSON.parse(zone.raw_geojson);
                        const centroid = getGeoJsonCentroid(geo);
                        if (centroid) {
                            if (!movement.has(entry.scouts_name)) movement.set(entry.scouts_name, []);
                            const path = movement.get(entry.scouts_name);
                            const last = path.slice(-1)[0];
                            if (!last || last.zoneName !== entry.zone) {
                                path.push({ zoneName: entry.zone, coords: geo.features[0].geometry.coordinates, centroid });
                            }
                        }
                    } catch (e) { console.warn("flow error", e); }
                });

            movement.forEach((visits, scoutName) => {
                const color = scoutColors[scoutName] || palette[0];
                if (!window.scoutLayers[scoutName]) window.scoutLayers[scoutName] = L.layerGroup();
                const group = window.scoutLayers[scoutName];
                for (let i = 0; i < visits.length - 1; i++) {
                    const start = getEdgeMidpoint(visits[i].coords);
                    const end = getEdgeMidpoint(visits[i + 1].coords);

                    const pathCoords = generateWalkPath(start, end);

                    const line = L.polyline(pathCoords, {
                        color,
                        weight: 2.5,
                        opacity: 0.8,
                        smoothFactor: 1.2,
                        lineJoin: 'round'
                    });
                    line.bindTooltip(`<div style='font-size:0.8125rem;'><strong>${scoutName}</strong><br>${visits[i].zoneName} → ${visits[i + 1].zoneName}</div>`);
                    group.addLayer(line);
                }
            });
        }

        const renderScoutLegend = (scoutColors) => {
            const legend = document.getElementById('scout-legend');
            legend.innerHTML = '';
            
            if (Object.keys(window.scoutLayers).length === 0) {
                legend.innerHTML = '<div class="empty-state"><p>No scouts found</p></div>';
                return;
            }

            Object.keys(window.scoutLayers).forEach(name => {
                const color = scoutColors[name];
                const item = document.createElement('label');
                item.className = 'legend-item';
                item.innerHTML = `
                    <input type="checkbox" data-scout="${name}" checked />
                    <span class="color-swatch" style="background:${color}"></span>
                    <span class="legend-label">${name}</span>`;
                const checkbox = item.querySelector('input');
                checkbox.addEventListener('change', e => {
                    const scoutName = e.target.dataset.scout;
                    const layer = window.scoutLayers[scoutName];
                    if (layer) {
                        if (e.target.checked) window.scoutedBedOverlay.addLayer(layer);
                        else window.scoutedBedOverlay.removeLayer(layer);
                    }
                });
                legend.appendChild(item);
            });
        };

        const renderZones = (data) => {
            addGreenhouseOverlay();  // ← ADDED: Renders greenhouse background first

            if (window.zoneLayer) map.removeLayer(window.zoneLayer);
            if (window.lineIdLabels) { map.removeLayer(window.lineIdLabels); window.lineIdLabels = null; }
            const lines = {};
            (data.all_zones_geojson || []).forEach(zone => {
                try {
                    const geo = JSON.parse(zone.raw_geojson);
                    const ghName = zone.name.split(" - ")[0];
                    if (geo.features) {
                        geo.features.forEach(f => {
                            const lid = f.properties.line_id;
                            const key = `${ghName}_line_${lid}`;
                            f.properties.zone_name = zone.name;
                            if (!lines[key]) lines[key] = [];
                            lines[key].push(f);
                        });
                    }
                } catch { }
            });

            window.lineIdLabels = L.layerGroup();
            Object.keys(lines).forEach(key => {
                const feats = lines[key];
                if (feats.length > 0) {
                    feats.sort((a, b) => a.properties.zone_id - b.properties.zone_id);
                    const coords = feats.flatMap(f => f.geometry.coordinates);
                    const lid = feats[0].properties.line_id;
                    const isOdd = parseInt(lid) % 2 !== 0;
                    const markerPoint = isOdd ? coords[0] : coords[coords.length - 1];
                    const lbl = L.marker([markerPoint[1], markerPoint[0]], {
                        icon: L.divIcon({
                            className: 'line-id-label',
                            html: `<div style="font-size:4px;font-weight:200;color:${darkFlavor ? '#fff' : '#000'};transform:rotate(45deg)">${lid}</div>`,
                            iconSize: [20, 10],
                            iconAnchor: [0, 0]
                        })
                    });
                    window.lineIdLabels.addLayer(lbl);
                }
            });

            const allFeats = { type: "FeatureCollection", features: Object.values(lines).flat() };
            window.zoneLayer = L.geoJSON(allFeats, {
                style: { color: darkFlavor ? '#fff' : '#1e293b', weight: 0.7, opacity: 0.6 },
                onEachFeature: (f, layer) => {
                    if (f.properties?.zone_name) {
                        const parts = f.properties.zone_name.split(" - ");
                        const html = parts.length >= 4
                            ? `<div style='font-size:0.75rem;line-height:1.5;'><strong style='display:block;margin-bottom:0.25rem;'>${parts[0]}</strong><div style='opacity:0.9;'>${parts[1]}</div><div style='opacity:0.9;'>${parts[2]}</div><div style='opacity:0.9;'>${parts[3]}</div></div>`
                            : f.properties.zone_name;
                        layer.bindTooltip(html);
                    }
                }
            });

            window.map.on('zoomend', () => {
                const z = window.map.getZoom();
                if (z >= 15) {
                    if (!window.map.hasLayer(window.zoneLayer)) window.zoneLayer.addTo(window.map);
                } else {
                    if (window.map.hasLayer(window.zoneLayer)) window.map.removeLayer(window.zoneLayer);
                }
                if (z >= 19) {
                    if (!window.map.hasLayer(window.lineIdLabels)) window.lineIdLabels.addTo(window.map);
                } else {
                    if (window.map.hasLayer(window.lineIdLabels)) window.map.removeLayer(window.lineIdLabels);
                }
            });

            const currentZoom = map.getZoom();
            if (currentZoom >= 15) window.zoneLayer.addTo(map);
            if (currentZoom >= 19) window.lineIdLabels.addTo(map);
        };

        initializeMap();
    };
</script>
{% endblock %}