{% extends "upande_scp/www/base.html" %}

{% block head %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
{% endblock %}


{% block page_content %}
<style>
    html,
    body {
        margin: 0;
        padding: 0;
        width: 100%;
        overflow-x: hidden;
    }

    .main-container {
        max-width: 100%;
    }

    #map-page {
        height: 100vh;
        width: 100%;
        position: relative;
    }

    #map-container,
    #map {
        height: 100%;
        width: 100%;
    }

    .leaflet-control-layers.leaflet-control-layers-expanded {
        padding: 6px;
    }

    .leaflet-control-layers-toggle {
        display: none;
    }

    #variety-legend {
        position: absolute;
        bottom: 1rem;
        left: 1rem;
        z-index: 1000;
        background: white;
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
        max-height: 50%;
        overflow-y: auto;
    }

    #variety-legend label {
        display: flex;
        align-items: center;
        cursor: pointer;
        margin-bottom: 0.5rem;
    }

    .line-id-label {
        font-family: sans-serif;
        pointer-events: none;
    }

    .protomaps-legend {
        background: white;
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.65);
        position: absolute;
        bottom: 3rem;
        right: 1rem;
        z-index: 1000;
        display: none;
    }

    .protomaps-legend label {
        display: block;
        cursor: pointer;
    }

    .leaflet-top.leaflet-right {
        margin-top: 4rem !important;
    }
    
    /* LOADER STYLES */
    #map-loader {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.9);
        z-index: 2000;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        color: #555;
        font-family: sans-serif;
    }

    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin-bottom: 10px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>


<div class="tw-bg-white tw-font-sans">
    <div class="main-container">
        <div id="map-loader">
            <div class="spinner"></div>
            <p>Loading variety map data...</p>
        </div>
        <div id="map-page" class="tw-w-full tw-h-full tw-p-0 tw-flex tw-flex-col">
            <div id="variety-legend" class="tw-bg-white tw-p-4 tw-rounded tw-shadow tw-space-y-2 tw-max-w-xs">
                <p class="tw-text-sm tw-font-semibold tw-mb-1">Varieties</p>
            </div>
            <div id="map-container" class="tw-w-full tw-flex-grow">
                <div id="map" class="tw-w-full tw-h-full"></div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-providers/1.13.0/leaflet-providers.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://unpkg.com/protomaps-leaflet@5.0.0/dist/protomaps-leaflet.js"></script>

    <script>
        window.map = null;
        let mapInitialized = false;
        window.zoneLayer = null;
        window.lineIdLabels = null;
        let protomapsLayer = null;
        let layersControl = null;
        let darkFlavor = false;
        window.lastVarietiesData = null;
        const varietyPalette = ['#F44336', '#E91E63', '#9C27B0', '#673AB7', '#3F51B5', '#2196F3', '#03A9F4', '#00BCD4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', '#FF5722'];

        const showLoader = () => {
            const loader = document.getElementById('map-loader');
            if (loader) loader.style.display = 'flex';
        };

        const hideLoader = () => {
            const loader = document.getElementById('map-loader');
            if (loader) loader.style.display = 'none';
        };

        const initializeMap = () => {
            if (mapInitialized) return;
            window.map = L.map('map', {
                zoomSnap: 0.1,
                zoomDelta: 0.1,
                maxZoom: 22.4,
                zoomControl: false
            });
            mapInitialized = true;
            renderBaseLayers();
            window.map.setView([0.0692, 35.7565], 18);
            fetchBedsAndZones();
        };

        const renderBaseLayers = () => {
            const googleSatelliteLayer = L.tileLayer(
                'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { maxZoom: 25 }
            );
            const openStreetMapLayer = L.tileLayer(
                'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 25 }
            );
            const osmSateliteLayer = L.tileLayer(
                'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 25 }
            );
            const pmtilesUrl = 'https://res.cloudinary.com/dorft5vxy/raw/upload/v1757410567/eldama-ravine_gdtrsv.pmtiles';
            protomapsLayer = protomapsL.leafletLayer({
                url: pmtilesUrl,
                flavor: "light",
                attribution: "© Protomaps © OpenStreetMap"
            });
            protomapsLayer.addTo(window.map);
            const baseMaps = {
                "Satellite View": googleSatelliteLayer,
                "Street Map": openStreetMapLayer,
                "OSM Satelite": osmSateliteLayer,
                "Protomaps Layer": protomapsLayer
            };
            layersControl = L.control.layers(baseMaps, {}, { collapsed: false, position: 'topright' }).addTo(window.map);
            const ProtomapsLegendControl = L.Control.extend({
                onAdd: function (map) {
                    const div = L.DomUtil.create('div', 'protomaps-legend');
                    div.innerHTML = `
                <p class="tw-text-sm tw-font-semibold tw-mb-1">Map Flavor</p>
                <label><input type="radio" name="flavor" value="light" checked> Light</label>
                <label><input type="radio" name="flavor" value="dark"> Dark</label>
                <label><input type="radio" name="flavor" value="white"> White</label>
                <label><input type="radio" name="flavor" value="grayscale"> Grayscale</label>
                <label><input type="radio" name="flavor" value="black"> Black</label>
            `;
                    L.DomEvent.on(div, 'change', (e) => {
                        if (e.target.name === 'flavor') {
                            const newFlavor = e.target.value;
                            darkFlavor = newFlavor === "dark" || newFlavor === "black";
                            if (window.map.hasLayer(protomapsLayer)) {
                                window.map.removeLayer(protomapsLayer);
                                layersControl.removeLayer(protomapsLayer);
                            }
                            protomapsLayer = protomapsL.leafletLayer({
                                url: pmtilesUrl,
                                flavor: newFlavor,
                                attribution: "© Protomaps © OpenStreetMap"
                            });
                            protomapsLayer.addTo(window.map);
                            layersControl.addBaseLayer(protomapsLayer, "Protomaps Layer");

                            if (window.lastVarietiesData) {
                                renderAllVarieties(window.lastVarietiesData);
                            }
                        }
                    });
                    return div;
                }
            });
            const protomapsLegend = new ProtomapsLegendControl({ position: 'bottomright' }).addTo(window.map);
            window.map.on('baselayerchange', function (e) {
                if (e.name === "Protomaps Layer") {
                    protomapsLegend.getContainer().style.display = 'block';
                } else {
                    protomapsLegend.getContainer().style.display = 'none';
                }
            });
        };

        const generateVarietyColors = (varieties) => {
            const varietyColors = {};
            varieties.forEach((variety, index) => {
                varietyColors[variety.variety] = varietyPalette[index % varietyPalette.length];
            });
            return varietyColors;
        };

        const renderVarietyLegend = (varietyColors) => {
            const varietyLegend = document.getElementById('variety-legend');
            varietyLegend.innerHTML = '<p class="tw-text-sm tw-font-semibold tw-mb-1">Varieties</p>';
            Object.keys(varietyColors).forEach(varietyName => {
                const color = varietyColors[varietyName];
                const legendItem = document.createElement('div');
                legendItem.className = 'tw-flex tw-items-center tw-space-x-2';
                legendItem.innerHTML = `
            <span class="tw-w-3 tw-h-3 tw-rounded-full tw-inline-block" style="background-color: ${color};"></span>
            <label class="tw-text-sm tw-text-gray-700">${varietyName}</label>
        `;
                varietyLegend.appendChild(legendItem);
            });
        };

        const fetchBedsAndZones = () => {
            showLoader();
            fetch('/api/method/upande_scp.serverscripts.get_beds_and_zones.getBedsAndZones', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(response_data => {
                    const varieties_array = response_data.data;

                    if (varieties_array && Array.isArray(varieties_array)) {
                        window.lastVarietiesData = varieties_array;
                        renderAllVarieties(varieties_array);
                    } else {
                        console.error('No varieties data found in the response or invalid data format.');
                        console.log('Full API Response:', response_data);
                    }
                })
                .catch(error => {
                    console.error('Error fetching beds and zones:', error);
                })
                .finally(() => {
                    hideLoader();
                });
        };

        const renderAllVarieties = (varietiesData) => {
            if (window.zoneLayer) window.map.removeLayer(window.zoneLayer);
            if (window.lineIdLabels) {
                window.map.removeLayer(window.lineIdLabels);
                window.lineIdLabels = null;
            }

            const varietyColors = generateVarietyColors(varietiesData);
            renderVarietyLegend(varietyColors);

            const lines = {};
            const allZoneFeatures = {
                type: "FeatureCollection",
                features: []
            };

            varietiesData.forEach(varietyItem => {
                const varietyName = varietyItem.variety;
                const color = varietyColors[varietyName];

                (varietyItem.beds || []).forEach(bed => {
                    (bed.zones || []).forEach(zone => {
                        try {
                            const geoJson = JSON.parse(zone.raw_geojson);
                            if (geoJson.features && Array.isArray(geoJson.features)) {
                                geoJson.features.forEach(feature => {
                                    const lineId = feature.properties.line_id;
                                    const greenhouseName = zone.name.split(" - ")[0];
                                    const uniqueKey = `${greenhouseName}_${varietyName}_line_${lineId}`;
                                    feature.properties.zone_name = zone.name;
                                    feature.properties.variety = varietyName;
                                    feature.properties.color = color;

                                    if (!lines[uniqueKey]) lines[uniqueKey] = [];
                                    lines[uniqueKey].push(feature);
                                });
                            }
                        } catch (e) {
                            console.error("Invalid GeoJSON for zone:", zone.name, e);
                        }
                    });
                });
            });

            window.lineIdLabels = L.layerGroup();

            Object.keys(lines).forEach(key => {
                const lineFeatures = lines[key];
                if (lineFeatures.length > 0) {
                    lineFeatures.sort((a, b) => a.properties.zone_id - b.properties.zone_id);
                    const allLineCoords = lineFeatures.flatMap(f => f.geometry.coordinates);
                    const lineId = lineFeatures[0].properties.line_id;
                    const isOdd = parseInt(lineId) % 2 !== 0;
                    const markerPoint = isOdd
                        ? allLineCoords[0]
                        : allLineCoords[allLineCoords.length - 1];
                    const lineIdLabel = L.marker([markerPoint[1], markerPoint[0]], {
                        icon: L.divIcon({
                            className: 'line-id-label',
                            html: `<div class="${darkFlavor ? 'tw-text-white' : 'tw-text-black'} tw-text-[7px] tw-font-thin" style="transform: rotate(45deg);">${lineId}</div>`,
                            iconSize: [20, 10],
                            iconAnchor: [0, 0]
                        })
                    });
                    window.lineIdLabels.addLayer(lineIdLabel);
                }
            });

            allZoneFeatures.features = Object.values(lines).flat();

            window.zoneLayer = L.geoJSON(allZoneFeatures, {
                style: (feature) => {
                    return {
                        color: feature.properties.color || '#000000',
                        weight: 0.6,
                        opacity: 0.8
                    };
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties && feature.properties.zone_id) {
                        const zoneName = feature.properties.zone_name || feature.properties.name || "";
                        const variety = feature.properties.variety || "N/A";
                        const parts = zoneName.split(" - ");
                        let tooltipHtml = `<strong>Variety:</strong> ${variety}<br>`;
                        if (parts.length >= 4) {
                            const [gh, kr, bed, zone] = parts;
                            tooltipHtml += `
                    <div class="tw-text-xs tw-leading-tight">
                        <strong>${gh}</strong><br>
                        ${kr}<br>
                        ${bed}<br>
                        ${zone}
                    </div>
                    `;
                        } else {
                            tooltipHtml += zoneName;
                        }
                        layer.bindTooltip(tooltipHtml, { permanent: false, direction: 'top' });
                    }
                }
            });

            window.map.on('zoomend', () => {
                const z = window.map.getZoom();
                if (window.zoneLayer) {
                    if (z >= 15) {
                        if (!window.map.hasLayer(window.zoneLayer)) window.zoneLayer.addTo(window.map);
                    } else {
                        if (window.map.hasLayer(window.zoneLayer)) window.map.removeLayer(window.zoneLayer);
                    }
                }
                if (window.lineIdLabels) {
                    if (z >= 18) {
                        if (!window.map.hasLayer(window.lineIdLabels)) window.lineIdLabels.addTo(window.map);
                    } else {
                        if (window.map.hasLayer(window.lineIdLabels)) window.map.removeLayer(window.lineIdLabels);
                    }
                }
            });

            if (window.map.getZoom() >= 15 && window.zoneLayer) {
                window.zoneLayer.addTo(window.map);
            }
            if (window.map.getZoom() >= 18 && window.lineIdLabels) {
                window.lineIdLabels.addTo(window.map);
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeMap);
        } else {
            initializeMap();
        }
    </script>
</div>
{% endblock %}